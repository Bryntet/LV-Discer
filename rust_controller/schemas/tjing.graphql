schema {
  query: RootQuery
  mutation: RootMutation
}

type RootQuery {
  isAuthenticated: Boolean!
  me: Me
  player(playerId: ID!): Player
  tour(tourId: ID!): Tour
  tours(filter: ToursFilterInput): [Tour!]!
  event(eventId: ID!): Event
  hasLicenceForEvent(eventId: ID!, teamId: ID): Boolean
  eventGame(eventGameId: ID!): EventGame
  eventGameScorecard(scorecardId: ID!): EventGameScorecard
  eventGameRound(roundId: ID!): EventGameRound
  eventSearch(skip: Int, query: String, dates: EventSearchDateInputType, sortBy: EventSearchSortInputType, distance: EventSearchDistanceInputType, pdgaTypes: [PdgaEventTypeEnum], tourTypes: [String], singles: Boolean): EventSearchResultType!
  shopItem(itemId: ID!): ShopItem
  eventItemShopImages(tourId: ID!): [EventShopItemImage]!
  tourImages(tourId: ID!): [TourImage]!
  round(roundId: ID!): Round
  pool(poolId: ID!): Pool
  group(groupId: ID!): Group
  layout(layoutId: ID!): Layout
  layoutVersion(layoutVersionId: ID!): LayoutVersion
  associations: [Organization!]!
  promoters: [Organization!]!
  eventPlayers(eventId: ID!, divisionId: ID, first: Float!, skip: Float!, search: String, orderBy: EventPlayersOrderByInput, direction: SortOrderType): [Player!]!
  eventRegistrations(eventId: ID!, divisionId: ID, status: RegistrationStatus!, first: Float!, skip: Float!, search: String, orderBy: EventRegistrationsOrderByInput, direction: SortOrderType): [Registration!]!
  eventTeamRegistrations(eventId: ID!, divisionId: ID, status: RegistrationStatus!, first: Float!, skip: Float!, orderBy: EventTeamsOrderByInput, direction: SortOrderType): [TeamRegistration!]!
  eventTeamPlayers(eventId: ID!, divisionId: ID, first: Float!, skip: Float!, orderBy: EventTeamsOrderByInput, direction: SortOrderType): [TeamPlayer!]!
  clubs(first: Float, skip: Float, filter: NameAndDistanceInput): [Organization!]!
  courses(first: Float, skip: Float, filter: NameAndDistanceInput): [SearchCourse!]!
  courseMapSearch(zoomLevel: Float!, minLat: Float!, maxLat: Float!, minLon: Float!, maxLon: Float!): [SearchCourseCombined!]!
  eventMessageCommentReplies(replyId: ID, first: Float, skip: Float): [EventMessageReply!]!
  eventMessageComments(eventMessageId: ID, first: Float, skip: Float): [EventMessageReply!]!
  team(teamId: ID!): Team
  teamPlayer(teamPlayerId: ID!): TeamPlayerType
  teamPlayers(teamId: ID!): [TeamPlayer!]!
  course(courseId: ID!): Course
  divisionTypes: [DivisionTypeItem!]!
  countries: [Country!]!
  tourTypes: [TourType!]!
  eventMessageAudienceTypes: [EventMessageAudience!]!
  eventMessageTypes: [EventMessageTypeType!]!
  pdgaEventTypes: [PdgaEventType!]!
  userPlayedLayouts(userId: ID!): UserPlayedLayouts!
  userEventCourseStats(userId: ID!, startDate: DateTime, endDate: DateTime, first: Float, skip: Float, layoutId: ID, sortBy: CourseStatsSortBy): CourseUserEventStats
  userCasualCourseStats(userId: ID!, startDate: DateTime, endDate: DateTime, first: Float, skip: Float, layoutId: ID, sortBy: CourseStatsSortBy): CourseUserCasualStats
  userStats(userId: ID!, startDate: DateTime, endDate: DateTime): Stats
  userCasualStats(userId: ID!, startDate: DateTime, endDate: DateTime): Stats
  user(userId: ID!): PublicUser!
  users(search: String, first: Float, skip: Float): [User!]
  citySearch(query: String!, geolocation: GeolocationInput): [City!]
  scorecard(scorecardId: ID!): Scorecard
  currencies(isEnabledForPayments: Boolean): [Currency!]!
  meta: Meta!
  customPointSystem(systemId: ID!): EventCustomPointsMap
  stripeAccount(stripeAccountId: ID!): StripeConnectedAccount
  organization(slug: String, organizationId: ID): Organization
  organizationContent(contentId: ID!): OrganizationContent
  eventRegistrationInvitation(invitationId: ID!): EventRegistrationInvitation
  organizationLeaderboard(leaderboardId: ID!, divisionType: String, page: Int): TourLeaderboardDivision
  playersWithoutGroups(roundId: ID!, eventId: ID!, first: Float, skip: Float): [Player]!
  teamsWithoutGroups(roundId: ID!, eventId: ID!, first: Float, skip: Float): [TeamPlayer]!
  subscriptions(returnUrl: String!): ManageSubscription
  packages(currency: String!): PackagePrices
  casualRoundsLeaderboard(startDate: DateTime, endDate: DateTime, first: Float, skip: Float, sortBy: CasualRoundsSortBy = RATING, direction: SortOrderType = ASC, uniqueUsers: Boolean = false): [CasualRoundLeaderboardEntry!]!
  competitiveRoundsLeaderboard(startDate: DateTime, endDate: DateTime, first: Float, skip: Float, sortBy: CompetitiveRoundsSortBy = RATING, direction: SortOrderType = ASC, uniqueUsers: Boolean = false): [CompetitiveRoundLeaderboardEntry!]!
}

"""The `Boolean` scalar type represents `true` or `false`."""
scalar Boolean

"""Information about the current logged in user"""
type Me {
  id: ID!
  firstName: String
  lastName: String
  email: String!
  isVerified: Boolean!
  profile: UserProfile!
  role: UserRole!
  favouriteEvents(first: Float, skip: Float, order: SortOrderType): [FavouriteEvent!]!
  myRegistrations(first: Float, skip: Float, order: SortOrderType, filter: RegistrationFilterMetaInput): [UserRegistrationsCombined!]!
  registrations(first: Float, skip: Float, order: SortOrderType, filter: RegistrationFilterMetaInput): [Registration!]!
  teamRegistrations(first: Float, skip: Float, order: SortOrderType, filter: RegistrationFilterMetaInput): [TeamRegistration!]!
  courses: [Course!]!
  gameStationlayouts: [EventGameStationLayout]!
  administratorRoles(first: Float, skip: Float, onlyCurrent: Boolean): [Administrator!]!
  courseAdministratorRoles: [CourseAdministrator!]!
  clubAdministratorRoles: [OrganizationAdministrator!]!
  pools(first: Float, status: PoolStatus, filter: PoolFilterMetaInput): [Pool]!
  teamPools(first: Float, status: PoolStatus, filter: PoolFilterMetaInput): [Pool]!
  groups(first: Float, filter: GroupsFilterInput): [Group]!
  teamGroups(first: Float, filter: GroupsFilterInput): [Group]!
  marshalls(first: Float, status: GroupStatus): [Group]!
  activeEventScorecards: [Group]!
  connectedAccounts: [StripeConnectedAccount]!
  tourPasses: [TourPass]!
  teams: [Team]!
  discStorage: [DiscStorage]!
  discs: [Disc]!
  scorecards(first: Float, skip: Float, filter: ScorecardFilterMetaInput, startDate: DateTime, endDate: DateTime): [Scorecard]!
  orderHistory(first: Int = 10, skip: Int = 0, eventIds: [ID]): [Order]!
  subscription: SubscriptionWithPackage
  clubs: [Organization]!
  mainClub: Organization
  friendshipRequests: [FriendshipRequest]!
  friendships(first: Int, skip: Int, search: String, blocked: Boolean): [Friendship]!
  recentFriendsActivities(first: Int, skip: Int, search: String): [ActivityUnion]!
  isPremium: Boolean!
  isPremiumOverride: Boolean!
  isPremiumOverrideExpiresAt: String
  subscriptionStatus: String
  lastSubscriptionSyncAt: String
}

"""The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID."""
scalar ID

"""The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text."""
scalar String

"""Detailed information about a user"""
type UserProfile {
  id: ID!
  gender: String
  club: String
  mainClubName: String
  mainClubSlug: String
  mainClubChangedAt: DateTime
  isActivePdgaMember: Boolean
  isPdgaOfficial: Boolean
  isPdgaPro: Boolean
  pdgaNumber: Float
  pdgaRating: Float
  pdgaOfficialExpirationDate: DateTime
  tjingRating: Float
  tjingCasualRating: Float
  tjingCombinedRating: Float
  country: Country
  phone: String
  instagram: String
  facebook: String
  twitter: String
  youtube: String
  tiktok: String
  sponsor: String
  sponsors: [UserSponsor]
  biography: String
  pinCode: String
  hasPinCode: Boolean
  isPublic: Boolean
  isPinCodeLocked: Boolean
  profileImageUrl: String
  birthDate: DateTime
  socialSecurityId: String
  teeOffSongUrl: String
}

"""A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar DateTime

"""The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)."""
scalar Float

"""List of countries with their name and 2-letter country code"""
type Country {
  name: String!
  code: CountryCode!
}

"""ISO-3166 2-letter country code. https://en.wikipedia.org/wiki/ISO_3166-1"""
enum CountryCode {
  """Afghanistan"""
  AF
  """Albania"""
  AL
  """Åland Islands"""
  AX
  """Algeria"""
  DZ
  """American Samoa"""
  AS
  """Andorra"""
  AD
  """Angola"""
  AO
  """Anguilla"""
  AI
  """Antigua"""
  AG
  """Argentina"""
  AR
  """Armenia"""
  AM
  """Aruba"""
  AW
  """Australia"""
  AU
  """Austria"""
  AT
  """Azerbaijan"""
  AZ
  """Bahrain"""
  BH
  """Bangladesh"""
  BD
  """Barbados"""
  BB
  """Belarus"""
  BY
  """Belgium"""
  BE
  """Belize"""
  BZ
  """Benin"""
  BJ
  """Bermuda"""
  BM
  """Bhutan"""
  BT
  """Bolivia"""
  BO
  """Bosnia and Herzegovina"""
  BA
  """Botswana"""
  BW
  """Brazil"""
  BR
  """British Indian Ocean Territory"""
  IO
  """British Virgin Islands"""
  VG
  """Brunei"""
  BN
  """Bulgaria"""
  BG
  """Burkina Faso"""
  BF
  """Burma Myanmar"""
  MM
  """Burundi"""
  BI
  """Cambodia"""
  KH
  """Cameroon"""
  CM
  """Canada"""
  CA
  """Cape Verde"""
  CV
  """Cayman Islands"""
  KY
  """Central African Republic"""
  CF
  """Indonesia"""
  ID
  """Chile"""
  CL
  """China"""
  CN
  """Colombia"""
  CO
  """Comoros"""
  KM
  """Cook Islands"""
  CK
  """Costa Rica"""
  CR
  """Côte d'Ivoire"""
  CI
  """Croatia"""
  HR
  """Cuba"""
  CU
  """Cyprus"""
  CY
  """Czech Republic"""
  CZ
  """Democratic Republic of Congo"""
  CD
  """Denmark"""
  DK
  """Djibouti"""
  DJ
  """Dominica"""
  DM
  """Dominican Republic"""
  DO
  """Ecuador"""
  EC
  """Egypt"""
  EG
  """El Salvador"""
  SV
  """Equatorial Guinea"""
  GQ
  """Eritrea"""
  ER
  """Estonia"""
  EE
  """Ethiopia"""
  ET
  """Falkland Islands"""
  FK
  """Faroe Islands"""
  FO
  """Federated States of Micronesia"""
  FM
  """Fiji"""
  FJ
  """Finland"""
  FI
  """France"""
  FR
  """French Guiana"""
  GF
  """French Polynesia"""
  PF
  """Gabon"""
  GA
  """Georgia"""
  GE
  """Germany"""
  DE
  """Ghana"""
  GH
  """Gibraltar"""
  GI
  """Greece"""
  GR
  """Greenland"""
  GL
  """Grenada"""
  GD
  """Guadeloupe"""
  GP
  """Guam"""
  GU
  """Guatemala"""
  GT
  """Guinea"""
  GN
  """Guinea-Bissau"""
  GW
  """Guyana"""
  GY
  """Haiti"""
  HT
  """Honduras"""
  HN
  """Hong Kong"""
  HK
  """Hungary"""
  HU
  """Iceland"""
  IS
  """India"""
  IN
  """Iran"""
  IR
  """Iraq"""
  IQ
  """Ireland"""
  IE
  """Israel"""
  IL
  """Italy"""
  IT
  """Jamaica"""
  JM
  """Japan"""
  JP
  """Jordan"""
  JO
  """Kazakhstan"""
  KZ
  """Kenya"""
  KE
  """Kiribati"""
  KI
  """Kosovo"""
  XK
  """Kuwait"""
  KW
  """Kyrgyzstan"""
  KG
  """Laos"""
  LA
  """Latvia"""
  LV
  """Lebanon"""
  LB
  """Lesotho"""
  LS
  """Liberia"""
  LR
  """Libya"""
  LY
  """Liechtenstein"""
  LI
  """Lithuania"""
  LT
  """Luxembourg"""
  LU
  """Macau"""
  MO
  """Macedonia"""
  MK
  """Madagascar"""
  MG
  """Malawi"""
  MW
  """Malaysia"""
  MY
  """Maldives"""
  MV
  """Mali"""
  ML
  """Malta"""
  MT
  """Marshall Islands"""
  MH
  """Martinique"""
  MQ
  """Mauritania"""
  MR
  """Mauritius"""
  MU
  """Mayotte"""
  YT
  """Mexico"""
  MX
  """Moldova"""
  MD
  """Monaco"""
  MC
  """Mongolia"""
  MN
  """Montenegro"""
  ME
  """Montserrat"""
  MS
  """Morocco"""
  MA
  """Mozambique"""
  MZ
  """Namibia"""
  NA
  """Nauru"""
  NR
  """Nepal"""
  NP
  """Netherlands"""
  NL
  """Netherlands Antilles"""
  AN
  """New Caledonia"""
  NC
  """New Zealand"""
  NZ
  """Nicaragua"""
  NI
  """Niger"""
  NE
  """Nigeria"""
  NG
  """Niue"""
  NU
  """Norfolk Island"""
  NF
  """North Korea"""
  KP
  """Northern Mariana Islands"""
  MP
  """Norway"""
  NO
  """Oman"""
  OM
  """Pakistan"""
  PK
  """Palau"""
  PW
  """Palestine"""
  PS
  """Panama"""
  PA
  """Papua New Guinea"""
  PG
  """Paraguay"""
  PY
  """Peru"""
  PE
  """Philippines"""
  PH
  """Poland"""
  PL
  """Portugal"""
  PT
  """Puerto Rico"""
  PR
  """Qatar"""
  QA
  """Republic of the Congo"""
  CG
  """Réunion"""
  RE
  """Romania"""
  RO
  """Russia"""
  RU
  """Rwanda"""
  RW
  """Saint Barthélemy"""
  BL
  """Saint Helena"""
  SH
  """Saint Kitts and Nevis"""
  KN
  """Saint Martin"""
  MF
  """Saint Pierre and Miquelon"""
  PM
  """Saint Vincent and the Grenadines"""
  VC
  """Samoa"""
  WS
  """San Marino"""
  SM
  """São Tomé and Príncipe"""
  ST
  """Saudi Arabia"""
  SA
  """Senegal"""
  SN
  """Serbia"""
  RS
  """Seychelles"""
  SC
  """Sierra Leone"""
  SL
  """Singapore"""
  SG
  """Slovakia"""
  SK
  """Slovenia"""
  SI
  """Solomon Islands"""
  SB
  """Somalia"""
  SO
  """South Africa"""
  ZA
  """South Korea"""
  KR
  """Spain"""
  ES
  """Sri Lanka"""
  LK
  """St. Lucia"""
  LC
  """Sudan"""
  SD
  """Suriname"""
  SR
  """Swaziland"""
  SZ
  """Sweden"""
  SE
  """Switzerland"""
  CH
  """Syria"""
  SY
  """Taiwan"""
  TW
  """Tajikistan"""
  TJ
  """Tanzania"""
  TZ
  """Thailand"""
  TH
  """The Bahamas"""
  BS
  """The Gambia"""
  GM
  """Timor-Leste"""
  TL
  """Togo"""
  TG
  """Tokelau"""
  TK
  """Tonga"""
  TO
  """Trinidad and Tobago"""
  TT
  """Tunisia"""
  TN
  """Turkey"""
  TR
  """Turkmenistan"""
  TM
  """Turks and Caicos Islands"""
  TC
  """Tuvalu"""
  TV
  """Uganda"""
  UG
  """Ukraine"""
  UA
  """United Arab Emirates"""
  AE
  """United Kingdom"""
  GB
  """United States"""
  US
  """Uruguay"""
  UY
  """US Virgin Islands"""
  VI
  """Uzbekistan"""
  UZ
  """Vanuatu"""
  VU
  """Vatican City"""
  VA
  """Venezuela"""
  VE
  """Vietnam"""
  VN
  """Wallis and Futuna"""
  WF
  """Yemen"""
  YE
  """Zambia"""
  ZM
  """Zimbabwe"""
  ZW
}

"""Information about user sponsor"""
type UserSponsor {
  id: ID!
  name: String!
  url: String
  createdAt: Boolean!
  updatedAt: Boolean!
}

enum UserRole {
  ADMIN
  USER
}

"""Events marked as favourite by the user"""
type FavouriteEvent {
  id: ID!
  event: Event!
  createdAt: DateTime!
}

"""Information about Event"""
type Event {
  id: ID!
  name: String!
  description: String
  isPublished: Boolean
  maxSpots: Float
  minGroupStartSize: Float
  maxRegistrations: Float
  maxWildcards: Float
  registrationMethod: RegistrationMethod!
  isRegistrationOpen: Boolean!
  registrationOpenAt: DateTime
  registrationCloseAt: DateTime
  tournamentDirectorName: String
  assistantTournamentDirectorName: String
  assistantTournamentDirectorPhone: String
  assistantTournamentDirectorEmail: String
  phone: String
  email: String
  registrationFeesInfo: String
  registrationFeeOverrides: [EventDivisionOverride]!
  paymentInfo: String
  location: String
  city: City
  website: String
  isResultSigningEnabled: Boolean!
  multipleScorecardModeEnabled: Boolean!
  isVerifyMode: Boolean!
  ratingEnabled: Boolean!
  groupSize: Float
  checkInStartsAt: DateTime
  checkInEndsAt: DateTime
  autoOpenRegistration: Boolean
  autoCloseInactivePools: Boolean
  type: EventCategoryEnum!
  singles: Boolean
  scoringAs: ScoringAs!
  autoConfirmRegistrations: Boolean
  teamSize: Float
  defaultToTeamName: Boolean
  pdgaEventId: String
  pdgaType: PdgaEventType
  waitinglistType: WaitinglistType
  agreementName: String
  agreementUrl: String
  startDate: DateTime
  endDate: DateTime
  isDeletable: Boolean!
  stripeAccountId: ID
  registrationInvitations: [EventRegistrationInvitation!]!
  contactList: [EventContactList!]!
  connectedAccount: StripeConnectedAccount
  status: EventStatus!
  waitingListLength: Float!
  registrationsCount: Float!
  registrations: [SingleAndDoubleRegistration!]!
  groupRegistrationReservations: [GroupRegistrationReservation!]!
  playersCount: Float!
  wildcardsCount: Float!
  registrationsCountPerDivision: EventRegistrationCount!
  isUserFavourite: Boolean!
  dnfDnsCount: [Player!]!
  players: [Player!]!
  teams: [TeamPlayer!]!
  tour: Tour!
  rounds: [Round]!
  eventMessageMeta: EventMessageCount
  userIsAdmin: Boolean
  eventMessages: [EventMessage]!
  tiebreaks: [EventTiebreakTypeCombined]!
  ties: [EventTiesTypeCombined!]!
  registrationStages: [RegistrationStage]!
  stats(divisionId: ID): Stats
  leaderboardPreviews: [EventLeaderboardDivisionCombined]!
  leaderboard(divisionId: ID, page: Int): EventLeaderboardDivisionCombined
  statsLeaderboards(divisionId: ID, page: Float, direction: SortOrderType, orderBy: TourStatsOrderByInput): StatsLeaderboard!
  userStats(userId: ID!): Stats
  shopItems: [ShopItem]!
  orders(first: Int = 10, skip: Int = 0, orderContentType: OrderContentType = ALL): GeneralOrderType
  userEventMeta: UserEventMetaTypeCombined
  ordersCount: Int!
  productsCount: Int!
  subscriptionTier: PackageTierEnum
  divisionInPool: [DivisionInPoolType]!
  divisions: [Division]!
  requireLicenceFrom: Organization
  requireLicenceFromForeignPlayers: Boolean
  requireOfficialStatus: Boolean
  requireOrganizationMembership: Boolean
  documents: [EvenDocument]!
  registrationQuestions: [RegistrationQuestion]!
  customPointSystem: EventCustomPointsMap
  countryRestrictions: [EventCountryRestriction]!
  coverImage: EventCoverImage
  penalties: [EventPlayerPenalty]!
  games: [EventGame]!
  galleryImages(first: Int = 10, skip: Int = 0, includePending: Boolean = false): [EventGalleryImage]!
}

enum RegistrationMethod {
  LIST
  GROUPS
  FLEX
}

"""An event level override for the registration fees specified on the tour divisions"""
type EventDivisionOverride {
  id: ID!
  eventId: ID!
  event: Event!
  divisionId: ID!
  division: Division!
  registrationFee: Float
  maxSpots: Float
  reservedSpots: Float
  maxRegistrations: Float
  refundPercentage: Float
  disabled: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about Division"""
type Division {
  id: ID!
  type: String!
  divisionTypeId: ID!
  isCustomDivision: Boolean!
  position: Float!
  name: String!
  maxSpots: Float
  reservedSpots: Float
  maxRegistrations: Float
  refundPercentage: Float
  canBeGenderLocked: Boolean
  isGenderLockedTo: GenderType
  canBeAgeRestricted: Boolean
  isAgeRestricted: Boolean
  ageRequirement: Float
  mustBeOrBelowAge: Boolean
  registrationFee: Money
  membershipRegistrationFee: Money
  tourPassFee: Money
  membershipTourPassFee: Money
  taxRate: TaxRate
  isDeletable: Boolean!
  tour: Tour!
  tourPasses: [DivisionTourPass!]!
  hasSamePriceEntireTour: Boolean!
}

enum GenderType {
  MALE
  FEMALE
}

type Money {
  value: Float!
  formatted: String!
  currency: String!
}

type TaxRate {
  id: String!
  display_name: String!
  active: Boolean!
  description: String
  inclusive: Boolean!
  percentage: Float!
}

"""Information about Tour"""
type Tour {
  id: ID!
  name: String!
  description: String
  type: TourType
  scoringType: ScoringType!
  scoreBasedOnNrOfEvents: Float
  sortLeaderboardByEventsPlayed: Boolean
  isPublished: Boolean!
  isPrivate: Boolean!
  paymentType: TourPaymentType!
  tourPasses: [TourPassCombined!]!
  userHasTourPass: Boolean
  usersTourPass(teamId: ID): TourPassCombined
  automaticRefunds: Boolean!
  allowRegistrationMessage: Boolean!
  userIsAdmin: Boolean
  isArchived: Boolean!
  isDeletable: Boolean!
  connectedAccount: StripeConnectedAccount
  status: TourStatus!
  eventsCount: Float!
  events: [Event]!
  administrators: [Administrator]!
  nextEvent: Event
  divisions: [Division]!
  statsLeaderboards(divisionId: ID, page: Float, direction: SortOrderType, orderBy: TourStatsOrderByInput, minEventsPlayed: Int): StatsLeaderboard!
  leaderboard(divisionId: ID, page: Int, numberOfEvents: Int, includeEventsWithoutResults: Boolean = false, includeUncompletedEvents: Boolean = false, scoringType: EventsScoringType): TourLeaderboardDivision
  gameLeaderboard(gameType: EventGameCategory!, divisionId: ID!): GameTourLeaderboardDivision
  customPointSystem: EventCustomPointsMap
  feeIncluded: Boolean!
  maxTourPassCount: Int
  currency: String!
  organizations: [Organization]!
  allowChangeCurrency: Boolean!
  subscriptionTier: PackageTierEnum
  hasActiveSubscription: Boolean
  ownershipTransfer: [TransferTourOwnershipType]!
  documents: [EvenDocument]!
  tourImages: [TourImage]!
  coverImage: EventCoverImage
  galleryImages(first: Int = 10, skip: Int = 0, includePending: Boolean = false): [EventGalleryImage]!
}

type TourType {
  name: String!
  type: String!
}

enum ScoringType {
  THROWS
  AVERAGE_THROWS
  POINTS
  DYNAMIC_POINTS
  CUSTOM_POINTS
  PAR
}

enum TourPaymentType {
  MANUAL
  MANAGED
}

union TourPassCombined = TourPass | TeamTourPass

type TourPass {
  id: ID!
  user: User!
  tour: Tour!
  division: Division!
  payment: Payment!
  order: Order
  divisionTourPass: DivisionTourPass
  createdAt: DateTime
}

"""Information about a user"""
type User {
  id: ID!
  firstName: String
  lastName: String
  isAnonymous: Boolean!
  email: String
  isDisabled: Boolean
  profile: UserProfile!
  teams: [Team]!
}

"""Information about Team"""
type Team {
  id: ID!
  name: String!
  type: TeamType
  archived: Boolean!
  teamPlayers: [TeamPlayerType!]!
  tjingRating: Float
  tjingCasualRating: Float
  tjingCombinedRating: Float
  createdByUser: User!
  updatedByUser: User!
}

enum TeamType {
  PERMANENT
  TEMPORARY
}

"""Information about Team Player"""
type TeamPlayerType {
  id: ID!
  userId: String!
  teamId: String!
  acceptedAt: DateTime
  status: TeamPlayerStatusType
  user: User!
}

enum TeamPlayerStatusType {
  ACCEPTED
  PENDING
  DECLINED
}

type Payment {
  id: ID!
  amount: Money
  isRefunded: Boolean!
  createdAt: DateTime!
}

"""Information about an order."""
type Order {
  id: ID!
  eventId: ID!
  user: User!
  status: String!
  totalAmount: Int!
  refundedAmount: Int!
  currency: String!
  url: String!
  createdAt: DateTime!
  lineItems: [LineItem]!
  comment: String
  refundHistory: [Refund]!
  registrationLineItem: OrderRegistrationType
  team: Team
}

"""The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1."""
scalar Int

"""Line Item of Order"""
type LineItem {
  id: ID!
  orderId: ID!
  shopItem: ShopItem!
  quantity: Int!
  amountSubTotal: Int!
  amountTotal: Int!
  refundStatus: Boolean!
  isDelivered: Boolean!
}

"""Information about a shop item."""
type ShopItem {
  id: ID!
  eventId: String!
  title: String!
  description: String
  productImage: EventShopItemImage
  link: String
  amount: Int!
  stock: Int!
  sales: Int!
  taxRate: TaxRate
  isPublished: Boolean!
  isAvailableAllEvents: Boolean!
  isDeletable: Boolean!
}

"""Information about available images"""
type EventShopItemImage {
  id: ID!
  imageUrl: String!
}

"""Order Refund"""
type Refund {
  id: String!
  amount: Int!
  currency: String!
  date: String!
  reason: String
}

"""Registration Line Item of Order"""
type OrderRegistrationType {
  hasTourPass: Boolean!
  amountSubTotal: Int!
  amountTotal: Int!
  refundStatus: Boolean!
  registration: SingleAndDoubleRegistration
}

union SingleAndDoubleRegistration = Registration | TeamRegistration

"""Registration to Division"""
type Registration {
  id: ID!
  date: DateTime!
  status: RegistrationStatus!
  createdAt: DateTime!
  statusUpdatedAt: DateTime!
  hasPaid: Boolean!
  division: Division!
  user: User!
  event: Event!
  logs: [RegistrationLog!]
  player: Player
  message: String
  responses: [RegistrationQuestionResponse]
  eventResult: EventResult
}

enum RegistrationStatus {
  PENDING
  ACCEPTED
  DECLINED
  USER_CANCELLED
  TEAM_CANCELLED
}

type RegistrationLog {
  id: ID!
  status: RegistrationStatus!
  actionedBy: User!
  createdAt: DateTime!
}

"""Information about a Player"""
type Player {
  id: ID!
  userId: ID!
  divisionId: ID!
  eventId: ID!
  isWildcard: Boolean!
  onSite: Boolean!
  hasPaid: Boolean!
  dnf: DNF!
  dns: DNS!
  eventTotal: Float
  registration: Registration!
  user: User!
  division: Division!
  event: Event!
  tiebreak: Tiebreak
  penalties: [EventPlayerPenalty!]
  boons: [EventPlayerBoon!]
}

"""Did not finish (DNF)"""
type DNF {
  isDnf: Boolean!
  reportedByUserId: ID
  reportedByUser: User
}

"""Did not start (DNS)"""
type DNS {
  isDns: Boolean!
  reportedByUserId: ID
  reportedByUser: User
}

type Tiebreak {
  id: ID!
  place: Float!
  playerId: ID!
  player: Player!
}

"""Penalties incurred by a player or team in an event outside of normal scoring."""
type EventPlayerPenalty {
  id: ID!
  eventId: ID!
  event: Event!
  poolId: ID
  pool: ID
  eventUserId: ID
  eventUser: ID
  eventTeamId: ID
  eventTeam: ID
  penalty: Float!
  reason: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Boons awarded to a player or team in an event to improve their score, par, or points."""
type EventPlayerBoon {
  id: ID!
  eventId: ID!
  event: Event!
  poolId: ID
  pool: ID
  eventPlayerId: ID
  eventPlayer: Player
  eventTeamId: ID
  eventTeam: TeamPlayerType
  par: Float
  score: Float
  points: Float
  onlyApplicableForTour: Boolean!
  icon: BoonIcon
  reason: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoonIcon {
  QUALIFIED
  CTP
  LONGEST_DRIVE
}

"""Response give by user to a specific question"""
type RegistrationQuestionResponse {
  id: ID!
  eventRegistrationId: ID
  question: String!
  response: String
  options: [RegistrationQuestionOption]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Option attached to a registration question"""
type RegistrationQuestionOption {
  id: ID!
  questionId: ID!
  value: String!
  position: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EventResult {
  totalScore: Float!
  totalPar: Float!
  totalPoints: Float!
  place: Float!
}

"""Team registration to Event & Division"""
type TeamRegistration {
  id: ID!
  date: DateTime!
  status: RegistrationStatus!
  createdAt: DateTime!
  statusUpdatedAt: DateTime!
  division: Division!
  team: Team!
  hasPaid: Boolean!
  player: TeamPlayer
  event: Event!
  logs: [RegistrationLog!]
  message: String
  responses: [RegistrationQuestionResponse]
  eventResult: EventResult
}

"""Information about a Team Player"""
type TeamPlayer {
  id: ID!
  teamId: ID!
  divisionId: ID!
  eventId: ID!
  isWildcard: Boolean!
  onSite: Boolean!
  hasPaid: Boolean!
  dnfDns: DNFDNS!
  registration: TeamRegistration!
  team: Team!
  division: Division!
  event: Event!
  eventTotal: Float
  tiebreak: Tiebreak
  penalties: [EventPlayerPenalty!]
  boons: [EventPlayerBoon]
}

"""Did not finish (DNF) - Did not start (DNS)"""
type DNFDNS {
  dnfDns: String
  dnfDnsErType: String
  reportedById: ID
}

"""Tour pass for a division"""
type DivisionTourPass {
  id: ID!
  divisionId: ID!
  name: String
  uses: Int
  stock: Int
  stockAvailable: Int
  usersUsesLeft: Int
  fee: Money
  membershipFee: Money
  active: Boolean!
  alwaysAvailable: Boolean!
  canBeDeleted: Boolean!
}

type TeamTourPass {
  id: ID!
  team: Team!
  tour: Tour!
  divisionTourPass: DivisionTourPass
  division: Division!
  payment: Payment!
  order: Order
  createdAt: DateTime
}

type StripeConnectedAccount {
  id: ID!
  name: String
  createdAt: DateTime!
  owner: User!
  taxRates: [TaxRate]!
}

enum TourStatus {
  CLOSED
  ONGOING
  COMPLETED
}

"""Information about an administrator"""
type Administrator {
  userId: ID!
  tourId: ID!
  role: AdministratorRole!
  user: User!
  tour: Tour!
}

enum AdministratorRole {
  OWNER
  ADMIN
}

type StatsLeaderboard {
  bestRound: StatsLeaderboardTop
  mostAces: StatsLeaderboardTop
  mostEagles: StatsLeaderboardTop
  mostBirdies: StatsLeaderboardTop
  mostPars: StatsLeaderboardTop
  mostCircleHits: StatsLeaderboardTop
  mostCircleHitConversions: StatsLeaderboardTop
  mostInsidePutts: StatsLeaderboardTop
  mostOutsidePutts: StatsLeaderboardTop
  leaderboardCount: Float!
  totalEventsCount: Float!
  leaderboard: [StatsLeaderboardPlayer]
  availableDivisionTypes: [DivisionTypeItem]!
}

type StatsLeaderboardTop {
  user: User
  team: Team
  par: Float
  part: Float
  count: Float
}

type StatsLeaderboardPlayer {
  position: Float!
  user: User
  team: Team
  division: Division
  bestRound: BestTourRound
  birdies: TourStat
  pars: TourStat
  aces: TourStat
  eagles: TourStat
  bogeys: TourStat
  doubleBogeys: TourStat
  trippleBogeysAbove: TourStat
  circleHits: TourStat
  circleHitConversions: TourStat
  insidePutts: TourStat
  outsidePutts: TourStat
  outOfBounds: TourStat
  penaltyStrokes: TourStat
}

type BestTourRound {
  poolId: ID
  eventId: ID
  roundId: ID
  par: Float
}

type TourStat {
  count: Float!
  part: Float!
}

type DivisionTypeItem {
  id: ID!
  position: Float!
  name: String!
  type: String!
  canBeGenderLocked: Boolean!
  canBeAgeRestricted: Boolean!
  ageRequirement: Float
}

enum SortOrderType {
  ASC
  DESC
}

enum TourStatsOrderByInput {
  BEST_ROUND
  ACE
  EAGLE
  BIRDIE
  PAR
  BOGEY
  DOUBLE_BOGEY
  TRIPLE_BOGEY_ABOVE
  CIRCLE_HIT
  CIRCLE_HIT_CONVERSION
  INSIDE_PUTT
  OUTSIDE_PUTT
  OUT_OF_BOUNDS
  PENALTY_STROKES
}

type TourLeaderboardDivision {
  id: ID!
  name: String!
  type: String!
  leaderboardCount: Float!
  players: [TourLeaderboardDivisionTypeCombined!]!
}

union TourLeaderboardDivisionTypeCombined = TourLeaderboardPlayer | TourLeaderboardTeamPlayer

type TourLeaderboardPlayer {
  place: Float!
  userId: ID!
  firstName: String!
  lastName: String!
  profileImageUrl: String
  pdgaNumber: Float
  pdgaRating: Float
  score: Float
  averageScore: Float
  par: Float
  points: Float
  eventScores: [TourLeaderboardEvent]!
  boons: [EventPlayerBoon]!
}

type TourLeaderboardEvent {
  eventId: ID!
  place: Float!
  score: Float!
  par: Float!
  points: Float!
  noResults: Boolean
}

type TourLeaderboardTeamPlayer {
  place: Float!
  team: Team!
  score: Float
  averageScore: Float
  par: Float
  points: Float
  eventScores: [TourLeaderboardEvent]!
  boons: [EventPlayerBoon]!
}

enum EventsScoringType {
  AVERAGE_THROWS
  PAR
  POINTS
  CUSTOM_POINTS
  THROWS
}

type GameTourLeaderboardDivision {
  id: ID!
  name: String!
  type: String!
  leaderboardCount: Float!
  players: [GameTourLeaderboardPlayer!]!
}

type GameTourLeaderboardPlayer {
  place: Float!
  userId: ID!
  firstName: String!
  lastName: String!
  profileImageUrl: String
  pdgaNumber: Float
  pdgaRating: Float
  score: Float
  averageScore: Float
}

enum EventGameCategory {
  PUTTING
  DISTANCE
  DISCGOLF
}

"""Message posted by an Admin for the event audience"""
type EventCustomPointsMap {
  id: ID!
  tourId: ID!
  eventId: ID
  positions: [EventCustomPoint]!
  defaultPoint: Float!
  tiePoints: TiePoint!
  createdAt: Float!
  updatedAt: Float!
}

type EventCustomPoint {
  place: Float!
  points: Float!
}

enum TiePoint {
  HIGHEST
  LOWEST
  AVERAGE
}

"""Information about an organization"""
type Organization {
  id: ID!
  administrators: [OrganizationAdministrator]!
  usersMembership: OrganizationMember
  type: OrganizationType!
  acceptMembers: AcceptMembers!
  tours: [Tour]!
  combinedLeaderboards: [OrganizationLeaderboard]!
  organizationStatsLeaderboards(tourIds: [ID], startDate: DateTime, endDate: DateTime, divisionType: String, page: Float, direction: SortOrderType, orderBy: TourStatsOrderByInput, minEventsPlayed: Int): StatsLeaderboard!
  organizationMemberStatsLeaderboards(startDate: DateTime, endDate: DateTime, divisionType: String, page: Float, direction: SortOrderType, orderBy: TourStatsOrderByInput, minEventsPlayed: Int): StatsLeaderboard!
  connectedOrganizationsCountByStatus: OrganizationConnectedOrganizationsCount!
  pendingConnectedOrganizations: [Organization]!
  connectedOrganizations(first: Float, skip: Float, order: SortOrderType): [Organization]!
  connectedOrganization: Organization
  organizationConnectionStatus: OrganizationConnectionStatus
  organizationConnectionUpdatedAt: DateTime!
  publicMembersList: Boolean!
  hidden: Boolean!
  name: String!
  slug: String!
  logoUrl: String
  coverImageUrl: String
  contactName: String
  contactMail: String
  contactPhone: String
  contactWebsite: String
  officials: [OrganizationOfficialType]!
  fiscalYearStartMonth: Int!
  shopItems: [ShopItem]!
  pendingMembers: [OrganizationMember]!
  memberCountByStatus: OrganizationMemberCount!
  members(order: SortOrderType, orderBy: OrderMembersByType, search: String): [OrganizationMember]!
  membersCount: Float!
  contactList: [OrganizationContactList!]!
  courseRelations: [OrganizationCourseRelation]!
  membershipTypes: [OrganizationMemberType]!
  sections: [OrganizationContent]!
  news(first: Float, skip: Float, order: SortOrderType): [OrganizationContent]!
  connectedAccount: StripeConnectedAccount
  currency: String!
  city: City
  orders(first: Int = 10, skip: Int = 0): [MembershipOrder]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an Organization administrator"""
type OrganizationAdministrator {
  role: OrganizationAdministrationRole!
  user: User!
  organization: Organization!
}

"""Roles for an organization"""
enum OrganizationAdministrationRole {
  ADMIN
  OWNER
}

"""Information about an organizations member"""
type OrganizationMember {
  id: ID!
  membershipType: OrganizationMemberType!
  organization: Organization!
  user: User!
  status: ID!
  usersMainClub: Boolean!
  usersMainClubUpdatedAt: DateTime
  expiresAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an organizations member"""
type OrganizationMemberType {
  id: ID!
  name: String!
  description: String!
  fee: Float!
  fullMember: Boolean!
  archived: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum OrganizationType {
  CLUB
  BUSINESS
  ASSOCIATION
  TEAM
}

enum AcceptMembers {
  DIRECT
  APPROVAL
  INVITATION
  CLOSED
}

"""A leaderboar created by handpicked events the organization is organizer for."""
type OrganizationLeaderboard {
  id: ID!
  title: String!
  description: String
  divisionTypes: [String!]!
  events: [Event]!
  configuration: [OrganizationLeaderboardConfiguration]!
  divisions(includeAllDivisions: Boolean = false): [OrganizationLeaderboardDivision]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Configuration for organization leaderbaords detemening best of for each tour in the leaderboard."""
type OrganizationLeaderboardConfiguration {
  id: ID!
  leaderboardId: ID!
  tourId: ID!
  bestOfNumberOfEvents: Float
}

"""Information about Division"""
type OrganizationLeaderboardDivision {
  name: String!
  type: String!
}

"""Information about an organizations number of connections with each status"""
type OrganizationConnectedOrganizationsCount {
  cancelled: Float!
  rejected: Float!
  approved: Float!
  pendingApproval: Float!
}

enum OrganizationConnectionStatus {
  PENDING_APPROVAL
  APPROVED
  REJECTED
  CANCELLED
}

"""Information about an organizations member"""
type OrganizationOfficialType {
  id: ID!
  role: String!
  email: String
  phone: String
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an organizations number of members with each status"""
type OrganizationMemberCount {
  pendingReview: Float!
  pendingPayment: Float!
  active: Float!
  expired: Float!
}

enum OrderMembersByType {
  NAME
  REPRESENTING
  MEMBERSHIP
  JOINED
  STATUS
}

"""Member contact information for the administrators"""
type OrganizationContactList {
  membershipTypeId: ID!
  userId: ID!
  profileImageUrl: String
  firstName: String!
  lastName: String!
  pdgaNumber: Float
  pdgaRating: Float
  phone: String
  email: String!
}

"""Information about an organizations relation to a specific course"""
type OrganizationCourseRelation {
  id: ID!
  course: Course!
  type: OrganizationCourseRelationType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about Course"""
type Course {
  id: ID!
  name: String!
  address: String
  phone: String
  website: String
  description: String
  access: CourseAccessType
  paymentInformation: String
  type: CourseType
  geolocation: Geolocation
  facilities: [CourseFacility]
  isPublished: Boolean
  publicStats: Boolean
  disableReviews: Boolean
  layouts(onlyPublished: Boolean): [Layout!]!
  courseAdmins: [CourseAdministrator!]!
  ratings(start: DateTime, end: DateTime): CourseLayoutRatings!
  casualUsageByWeekday(startDate: DateTime, endDate: DateTime): CourseWeekdayUsage!
  casualUsageByMonth(startDate: DateTime, endDate: DateTime): CourseMonthUsage!
  eventsByMonth(startDate: DateTime, endDate: DateTime): CourseMonthEvents!
  events: [Event!]!
  courseImages: [CourseImage]!
  coverImage: CourseImage
}

enum CourseAccessType {
  PUBLIC
  PRIVATE
  RESERVE
}

enum CourseType {
  PUBLIC
  CUSTOM
}

type Geolocation {
  lat: Float!
  lng: Float!
}

"""Information about Course"""
type CourseFacility {
  id: ID!
  courseId: ID!
  name: String!
  type: CourseFacilityEnum!
  geolocation: Geolocation
}

enum CourseFacilityEnum {
  COURSE_SHOP
  GROCERY_STORE
  CAFE
  GAS_STATION
  WATER
  PARKING
  RESTAURANT
  INFORMATION
  RESTROOMS
  OTHER
}

"""Information about Layout"""
type Layout {
  id: ID!
  published: Boolean!
  name: String!
  type: CourseType
  description: String
  baskets: String
  teepads: String
  color: LayoutColorType
  dogFriendly: Boolean
  wheelchairAccessible: Boolean
  strollerAccessible: Boolean
  cartAccessible: Boolean
  openForPlay: Boolean
  payToPlay: Boolean
  difficulty: LayoutDifficultyType
  upkeep: LayoutUpkeepType
  canBeDeleted: Boolean!
  course: Course
  reviewsCount(start: DateTime, end: DateTime): Float!
  usersLatestReview: CourseLayoutReview
  casualLeaderboard(layoutVersionId: ID, start: DateTime, end: DateTime, first: Float, skip: Float): LayoutCasualStats
  competitionLeaderboard(layoutVersionId: ID, start: DateTime, end: DateTime, first: Float, skip: Float): LayoutEventStats
  casualUsageByWeekday(startDate: DateTime, endDate: DateTime): CourseWeekdayUsage!
  casualUsageByMonth(startDate: DateTime, endDate: DateTime): CourseMonthUsage!
  eventsByMonth(startDate: DateTime, endDate: DateTime): CourseMonthEvents!
  reviews(start: DateTime, end: DateTime, first: Float, skip: Float): [CourseLayoutReview!]!
  ratings(start: DateTime, end: DateTime): CourseLayoutRatings!
  versions: [LayoutVersion]!
  latestVersion: LayoutVersion!
}

enum LayoutColorType {
  WHITE
  BLACK
  GREEN
  BLUE
  RED
  ORANGE
  YELLOW
  GOLD
}

enum LayoutDifficultyType {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  PRO
}

enum LayoutUpkeepType {
  POOR
  DECENT
  GREAT
}

"""Reviews for a specific layout"""
type CourseLayoutReview {
  id: ID!
  layoutId: ID!
  layoutVersionId: ID!
  user: User!
  review: String
  rating: Float
  teepads: Float
  baskets: Float
  upkeep: Float
  navigation: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LayoutCasualStats {
  numberOfRoundsPlayed: Float!
  averageRound: Float!
  averagePar: Float!
  rounds: [LayoutCasualRound]
}

type LayoutCasualRound {
  userId: ID!
  user: User!
  scorecardId: ID!
  scorecard: Scorecard!
  date: DateTime!
  position: Float!
  layoutPar: Float!
  totalThrows: Float!
  totalPar: Float!
  rating: Float
}

type Scorecard {
  id: ID!
  date: DateTime!
  status: ScorecardStatus!
  name: String
  playFormat: ScorecardPlayFormat!
  currentResultsCount: Float!
  maxResultsCount: Float!
  layoutVersion: LayoutVersion!
  startHole: Hole!
  players: [ScorecardPlayer!]!
  weather: Weather
  createdAt: DateTime!
  createdById: ID!
}

enum ScorecardStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

enum ScorecardPlayFormat {
  STANDARD
  PRACTICE
  MULLIGAN
  BEST_SHOT
  MODIFIED_BEST_SHOT
  GREENSOME
  TOUGH_SHOT
  WORST_SHOT
  TWO_DISC
  THREE_DISC
  X_DISC
  MATCH_PLAY
}

type LayoutVersion {
  id: ID!
  version: Float!
  holes: [Hole!]!
  canAddOrRemoveHoles: Boolean!
  hasResults: Boolean!
  isDeletable: Boolean!
  difficultyDistance: Float
  difficultyTerrain: Float
  difficultyPrecision: Float
  difficultyObstacles: Float
  difficultyRating: Float
  createdAt: DateTime!
  layout: Layout!
}

"""Information about Hole"""
type Hole {
  id: ID!
  number: Float!
  par: Float
  name: String
  length: Float
  measureInMeters: Boolean
  note: String
  userNote: [HoleUserNote]
  hasOb: Boolean!
  hasMandatory: Boolean!
  hasHazard: Boolean!
  hasLocalRule: Boolean!
  geolocation: [Geolocation]
}

"""Users private note about a hole"""
type HoleUserNote {
  id: ID!
  holeId: ID!
  note: String!
  createdAt: DateTime!
}

type ScorecardPlayer {
  id: ID!
  position: Float!
  scoringMode: ScoringModeType!
  user: TeamAndUserAndAnonymousUser!
  results: [ScorecardResult!]!
  throws: [Throw!]!
  throwStats: ExtendedStatsSummaryType!
  tjingRating: Float
}

enum ScoringModeType {
  STANDARD
  EXTENDED
}

union TeamAndUserAndAnonymousUser = User | AnonymousUser | Team

type AnonymousUser {
  id: ID!
  name: String!
  isAnonymous: Boolean!
}

type ScorecardResult {
  id: ID!
  score: Float!
  isTapIn: Boolean!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean!
  penaltyStrokes: Float!
  hole: Hole!
  throws: [Throw]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Throw {
  id: ID!
  hole: Hole!
  userId: ID
  teamId: ID
  disc: Disc
  throwNumber: Float!
  inTheBasket: Boolean!
  distanceToBasket: Float!
  lie: Lie!
  lieGeolocation: Geolocation
  lieDifficulty: LieDifficulty
  throwType: ThrowType
  restriction: ThrowRestriction
  shotShape: ShotShape
  nearMiss: NearMiss
  penalties: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about a specific disc"""
type Disc {
  id: ID!
  owner: User!
  ownerHistory: [User!]!
  measuredThrows: [User!]!
  brand: String!
  mold: String!
  plastic: String!
  color: String!
  speed: Float!
  glide: Float!
  turn: Float!
  fade: Float!
  userEstimatedSpeed: Float
  userEstimatedGlide: Float
  userEstimatedTurn: Float
  userEstimatedFade: Float
  condition: Float
  description: String
  storagePosition: Float
  storageId: ID
  imageUrl: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

enum Lie {
  TEE
  FAIRWAY
  OFF_FAIRWAY
  C1
  C2
  TAP_IN
  DROPZONE
  RE_THROW
  RE_TEE
  OTHER
}

enum LieDifficulty {
  CLEAR
  OBSTRUCTED
  BLOCKED
}

enum ThrowType {
  BACKHAND
  FOREHAND
  TOMAHAWK
  THUMBER
  ROLLER
  PUTT
}

enum ThrowRestriction {
  MANDO_MISS
  OUT_OF_BOUNDS
  HAZARD
  LOST_DISC
}

enum ShotShape {
  HYZER
  FLAT
  ANHYZER
}

enum NearMiss {
  BAND
  RIM
  WEAK_SIDE_CHAINS
  STRONG_SIDE_CHAINS
}

"""Summary view of extended stats and throw by throw."""
type ExtendedStatsSummaryType {
  throwsCount: Float!
  fairwayHits: ExtendedStatsDetail!
  totalPossibleFairwayHits: Float!
  scrambles: ExtendedStatsDetail!
  totalPossibleScrambles: Float!
  averageDistanceFromTee: Float!
  longestDistanceFromTee: Float!
  totalDistanceFromTee: Float!
  bullsEyeHits: ExtendedStatsDetail!
  bullsEyeHitConversions: ExtendedStatsDetail!
  c1xHits: ExtendedStatsDetail!
  c1xHitConversions: ExtendedStatsDetail!
  c1xPutts: Float!
  c1xPuttConversions: Float!
  c2Hits: ExtendedStatsDetail!
  c2HitConversions: ExtendedStatsDetail!
  c2Putts: ExtendedStatsDetail!
  shortestPuttDistance: Float!
  longestPuttDistance: Float!
  averagePuttDistance: Float!
  totalPuttDistance: Float!
  penalties: Float!
  lostDiscs: Float!
  reThrows: Float!
  mandatoryMisses: Float!
  hazards: Float!
  outOfBounds: Float!
  dropzones: Float!
  lieDifficulties: ExtendedStatsLieDifficulty!
  shotShapes: ExtendedStatsShotShape!
  throwTypes: ExtendedStatsThrowType!
  nearMisses: ExtendedStatsNearMiss!
  madePutts: Float!
  throwIns: Float!
  longestThrowInDistance: Float!
  inTheBasketFromOutsideC2: [Throw]!
}

type ExtendedStatsDetail {
  count: Float!
  part: Float!
}

type ExtendedStatsLieDifficulty {
  clear: ExtendedStatsDetail!
  obstructed: ExtendedStatsDetail!
  blocked: ExtendedStatsDetail!
}

type ExtendedStatsShotShape {
  hyzer: ExtendedStatsDetail!
  flat: ExtendedStatsDetail!
  anhyzer: ExtendedStatsDetail!
}

type ExtendedStatsThrowType {
  backhand: ExtendedStatsDetail!
  forehand: ExtendedStatsDetail!
  tomahawk: ExtendedStatsDetail!
  thumber: ExtendedStatsDetail!
  roller: ExtendedStatsDetail!
}

type ExtendedStatsNearMiss {
  strongSide: ExtendedStatsDetail!
  weakSide: ExtendedStatsDetail!
  rim: ExtendedStatsDetail!
  band: ExtendedStatsDetail!
}

type Weather {
  id: ID!
  windDirection: WindDirection!
  condition: String!
  windKph: String!
  gustKph: String!
  precipitationMm: String!
  temperatureC: String!
  feelsLikeC: String!
  createdAt: String!
  updatedAt: String!
}

enum WindDirection {
  N
  NNE
  NE
  ENE
  E
  ESE
  SE
  SSE
  S
  SSW
  SW
  WSW
  W
  WNW
  NW
  NNW
}

type LayoutEventStats {
  numberOfRoundsPlayed: Float!
  averageRound: Float!
  averagePar: Float!
  rounds: [LayoutEventRoundType]
}

type LayoutEventRoundType {
  userId: ID!
  user: User!
  groupId: ID!
  poolId: ID!
  pool: Pool!
  roundId: ID!
  round: Round!
  eventId: ID!
  event: Event!
  date: DateTime!
  position: Float!
  layoutPar: Float!
  totalThrows: Float!
  totalPar: Float!
  rating: Float
}

"""Information about Pool"""
type Pool {
  id: ID!
  date: DateTime!
  endDate: DateTime
  status: PoolStatus!
  position: Float!
  name: String
  startMethod: PoolStartMethod!
  playFormat: PoolPlayFormat
  areGroupsPublic: Boolean!
  layoutVersion: LayoutVersion
  round: Round!
  isDeletable: Boolean!
  hasResults: Boolean!
  groups(userId: ID): [Group!]!
  holeStats(divisionId: ID): [HoleStats!]
  stats(divisionId: ID): Stats
  userStats(userId: ID!): Stats
  livescore(divisionId: ID, page: Int, watchedUserIds: [ID], watchedTeamIds: [ID]): PoolLivescoreDivisionCombined
  leaderboard(divisionId: ID, page: Int): PoolLeaderboardDivisionCombined
  weather: Weather
  statsLeaderboards(divisionId: ID, page: Float, direction: SortOrderType, orderBy: TourStatsOrderByInput): StatsLeaderboard!
}

enum PoolStatus {
  CLOSED
  PREPARE
  OPEN
  PAUSE
  COMPLETED
}

enum PoolStartMethod {
  SHOTGUN
  TEETIME
  FLEX
}

enum PoolPlayFormat {
  BEST_SCORE
  BEST_SHOT
  MODIFIED_BEST_SHOT
  GREENSOME
  MODIFIED_GREENSOME
  COMBINED_SCORE
  TOUGH_SHOT
  WORST_SHOT
  ALTERNATE_THROW
}

"""Information about Round"""
type Round {
  id: ID!
  status: RoundStatus!
  isDeletable: Boolean!
  event: Event!
  pools: [Pool!]!
}

enum RoundStatus {
  CLOSED
  ONGOING
  COMPLETED
}

type Group {
  id: ID!
  status: GroupStatus!
  position: Float!
  startsAt: DateTime
  startHole: Hole
  pool: Pool!
  designatedSinglesScorer: User
  designatedTeamsScorer: Team
  playerConnections: [GroupPlayerConnection!]!
  playerConnectionsV2: [GroupPlayerConnectionTypeCombined!]!
  results(isVerified: Boolean): [Result!]!
  hasResults: Boolean!
  resultsV2(isVerified: Boolean): [Result!]
  marshall: User
  verifierDisabled: Boolean!
}

enum GroupStatus {
  CLOSED
  OPEN
  DONE
}

"""Information about a connection between a Group and a Player"""
type GroupPlayerConnection {
  id: ID!
  position: Float!
  playerId: ID!
  groupId: ID!
  roundTotal: Float
  tjingRating: Float
  player: Player!
  hasSignedResult: Boolean!
  group: Group!
}

union GroupPlayerConnectionTypeCombined = GroupPlayerConnection | GroupTeamPlayerConnection

"""Information about a connection between a Group and a Team Player"""
type GroupTeamPlayerConnection {
  id: ID!
  position: Float!
  teamPlayerId: ID!
  groupId: ID!
  teamPlayer: TeamPlayer!
  roundTotal: Float
  tjingRating: Float
  hasSignedResult: Boolean!
  group: Group!
}

type Result {
  id: ID!
  score: Float!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean!
  penaltyStrokes: Float!
  createdByUserId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  hash: String!
  createdByUser: User!
  updatedByUserId: ID!
  updatedByUser: User!
  isVerified: Boolean!
  verifiedByUserId: ID
  verifiedByUser: User
  playerConnection: GroupPlayerConnection!
  playerConnectionV2: GroupPlayerConnectionTypeCombined!
  hole: Hole!
}

type HoleStats {
  id: ID!
  number: Float!
  name: String
  par: Float!
  averageScore: Float!
  aces: StatsDetail!
  circleHits: StatsDetail!
  circleHitConversions: StatsDetail!
  insidePutts: StatsDetail!
  outsidePutts: StatsDetail!
  outOfBounds: StatsDetail
  penaltyStrokes: StatsDetail!
  eagles: StatsDetail!
  birdies: StatsDetail!
  pars: StatsDetail!
  bogeys: StatsDetail!
  doubleBogeys: StatsDetail!
  trippleBogeysAbove: StatsDetail!
}

type StatsDetail {
  count: Float!
  part: Float!
}

"""Stats"""
type Stats {
  aces: StatsDetail!
  circleHits: StatsDetail!
  circleHitConversions: StatsDetail!
  insidePutts: StatsDetail!
  outsidePutts: StatsDetail!
  outOfBounds: StatsDetail
  penaltyStrokes: StatsDetail!
  eagles: StatsDetail!
  birdies: StatsDetail!
  pars: StatsDetail!
  bogeys: StatsDetail!
  doubleBogeys: StatsDetail!
  trippleBogeysAbove: StatsDetail!
  throwCount: Float!
  holesPlayed: Float!
  layoutsPlayed: Float!
  coursesPlayed: Float!
  totalPar: Float
}

union PoolLivescoreDivisionCombined = PoolLivescoreDivision | PoolLivescoreDivisionTeam

type PoolLivescoreDivision {
  id: ID!
  name: String!
  type: String!
  players: [PoolLivescorePlayer!]!
  totalPlayers: Float!
  watchedUsers: [PoolLivescorePlayer!]!
}

type PoolLivescorePlayer {
  place: Float!
  placeChange: Float
  playerId: ID!
  userId: ID!
  firstName: String!
  lastName: String!
  profileImageUrl: String
  country: Country
  pdgaNumber: Float
  startsAt: DateTime
  isDnf: Boolean!
  isDns: Boolean!
  totalScore: Float
  totalPar: Float
  stats: Stats
  results: [PoolLivescoreResult!]!
}

type PoolLivescoreResult {
  id: ID!
  score: Float!
  holeId: ID!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean
  penaltyStrokes: Int
}

type PoolLivescoreDivisionTeam {
  id: ID!
  name: String!
  type: String!
  players: [PoolLivescoreTeamPlayer!]!
  totalPlayers: Float!
  watchedTeams: [PoolLivescoreTeamPlayer!]!
}

type PoolLivescoreTeamPlayer {
  place: Float!
  placeChange: Float
  team: Team!
  startsAt: DateTime
  dnfDns: String
  totalScore: Float
  totalPar: Float
  stats: Stats
  results: [PoolLivescoreResult!]!
}

union PoolLeaderboardDivisionCombined = PoolLeaderboardDivision | PoolLeaderboardDivisionTeam

type PoolLeaderboardDivision {
  id: ID!
  name: String!
  type: String!
  players: [PoolLeaderboardPlayer!]!
  totalPlayers: Float!
}

type PoolLeaderboardPlayer {
  place: Float!
  playerId: ID!
  userId: ID!
  firstName: String!
  lastName: String!
  profileImageUrl: String
  pdgaNumber: Float
  pdgaRating: Float
  isDnf: Boolean!
  isDns: Boolean!
  score: Float
  par: Float
  points: Float
  results: [SimpleResult!]!
  penalties: [EventPlayerPenalty]!
  tjingRating: Float
}

type SimpleResult {
  id: ID!
  score: Float!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean!
  penaltyStrokes: Float!
  hole: Hole!
}

type PoolLeaderboardDivisionTeam {
  id: ID!
  name: String!
  type: String!
  players: [PoolLeaderboardTeamPlayer!]!
  totalPlayers: Float!
}

type PoolLeaderboardTeamPlayer {
  place: Float!
  team: Team!
  isDnfDns: Boolean
  dnfOrDns: String
  score: Float
  par: Float
  points: Float
  results: [SimpleResult!]!
  penalties: [EventPlayerPenalty]!
  rating: Float
}

"""Information about casual rounds per weekday"""
type CourseWeekdayUsage {
  totalUsers: Float!
  monday: Float!
  tuesday: Float!
  wednesday: Float!
  thursday: Float!
  friday: Float!
  saturday: Float!
  sunday: Float!
}

"""Information about casual rounds per weekday"""
type CourseMonthUsage {
  totalUsers: Float!
  totalUniqueUsers: Float!
  totalScorecards: Float!
  january: Float!
  february: Float!
  march: Float!
  april: Float!
  may: Float!
  june: Float!
  july: Float!
  august: Float!
  september: Float!
  october: Float!
  november: Float!
  december: Float!
}

"""Information about events on the course by month"""
type CourseMonthEvents {
  totalPlayers: Float!
  uniquePlayers: Float!
  totalEvents: Float!
  totalRounds: Float!
  sanctionedEvents: Float!
}

"""Ratings for various aspects of the layout"""
type CourseLayoutRatings {
  layout: Float
  teepads: Float
  baskets: Float
  upkeep: Float
  navigation: Float
}

"""Information about a Course administrator"""
type CourseAdministrator {
  userId: ID!
  courseId: ID!
  course: Course!
  role: CourseAdministratorRole!
  user: User!
}

enum CourseAdministratorRole {
  OWNER
  ADMIN
}

type CourseImage {
  id: ID!
  imageUrl: String!
  createdAt: DateTime!
}

"""The relations an organization can have to a course"""
enum OrganizationCourseRelationType {
  HOME_COURSE
  EVENT_ORGANIZER
  MAINTAINER
}

"""Information about an organizations content"""
type OrganizationContent {
  id: ID!
  organization: Organization!
  type: OrganizationContentType!
  audience: OrganizationContentAudience!
  title: String!
  published: Boolean!
  position: Float
  body: String!
  attachments: [OrganizationConentDocument]!
  createdBy: User!
  createdAt: DateTime!
  updatedBy: User!
  updatedAt: DateTime!
}

"""Audience for an organizations content"""
enum OrganizationContentType {
  SECTION
  NEWS
}

"""Audience for an organizations content"""
enum OrganizationContentAudience {
  MEMBER
  PUBLIC
}

"""Uploaded documents available on this content"""
type OrganizationConentDocument {
  id: ID!
  documentType: EventDocumentType!
  url: String!
  createdBy: User!
  createdAt: DateTime!
}

enum EventDocumentType {
  DOCUMENT
  IMAGE
}

type City {
  id: ID!
  name: String!
  country: String!
  county: String!
  geolocation: Geolocation!
}

"""Information about an order."""
type MembershipOrder {
  id: ID!
  user: User!
  status: String!
  totalAmount: Int!
  refundedAmount: Int!
  currency: String!
  url: String!
  createdAt: DateTime!
  comment: String
  refundHistory: [Refund]!
}

enum PackageTierEnum {
  FREE
  ESSENTIAL
  PRO
}

"""Information about transferring subscription ownership"""
type TransferTourOwnershipType {
  id: String!
  transferToken: String!
  status: String!
  email: String!
  expiresAt: DateTime
  createdAt: DateTime
}

"""Uploaded documents available on this event"""
type EvenDocument {
  id: ID!
  eventId: String!
  documentType: EventDocumentType!
  displayName: String!
  url: String!
  tourAvailable: Boolean!
  createdBy: User!
  createdAt: DateTime!
}

"""Information about available images"""
type TourImage {
  id: ID!
  imageUrl: String!
}

"""Country restrictions for this event, primarily used in the registration process"""
type EventCoverImage {
  id: ID!
  tourId: ID
  url: String
}

"""An image in the event gallery"""
type EventGalleryImage {
  id: ID!
  eventId: ID!
  imageUrl: String
  description: String
  status: GalleryImageStatus!
  uploadToken: String!
  uploadedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GalleryImageStatus {
  PENDING
  PUBLISHED
}

enum EventCategoryEnum {
  GAME
  DISCGOLF
}

enum ScoringAs {
  SINGLES
  DOUBLES
  RANDOM_DOUBLES
}

type PdgaEventType {
  name: String!
  type: PdgaEventTypeEnum!
}

enum PdgaEventTypeEnum {
  PDGA_A
  PDGA_B
  PDGA_C
  PDGA_X
  PDGA_L
}

"""
    Only a toggle used by fontend for sorting waitinglist, no API logic impact.
    * Combined creates one big waitingllist in ascending order based on registration.
    * Division sorts ascending order but grouped by division.
  """
type WaitinglistType {
  name: String!
  type: WaitingListTypeEnum!
}

enum WaitingListTypeEnum {
  DIVISION
  COMBINED
}

type EventRegistrationInvitation {
  id: ID!
  eventId: ID!
  event: Event!
  status: EventRegistrationInvitationStatus!
  type: EventRegistrationInvitationTypeType!
  usageCount: Float!
  acceptedByUser: User
  createdByUser: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum EventRegistrationInvitationStatus {
  PENDING
  USED
  CANCELLED
}

enum EventRegistrationInvitationTypeType {
  SINGLE_USE
  MULTI_USE
}

"""Contact information to the players in an event for the TD"""
type EventContactList {
  userId: String!
  registrationStatus: RegistrationStatus!
  profileImageUrl: String
  firstName: String!
  lastName: String!
  club: String
  mainClubSlug: String
  mainClubName: String
  organizationMemberships: [OrganizationMember]!
  mainClubChangedAt: DateTime
  pdgaNumber: Float
  pdgaRating: Float
  phone: String
  email: String!
  teeOffSongUrl: String
  team: Team
}

enum EventStatus {
  CLOSED
  ONGOING
  COMPLETED
}

type GroupRegistrationReservation {
  id: ID!
  expireAt: DateTime!
  group: Group!
  user: User!
  event: Event!
}

"""Information about mount  registrations for an event in total and per division."""
type EventRegistrationCount {
  totalAccepted: Float!
  totalWaiting: Float!
  totalCancelled: Float!
  countPerDivision: [PlayerCount]!
}

"""Information about a Player"""
type PlayerCount {
  divisionId: ID!
  totalCount: Float!
  acceptedCount: Float!
  waitingCount: Float!
  cancelledCount: Float!
}

"""Showing some meta data for the event messages without fetching the messages themselves."""
type EventMessageCount {
  accepted: Float!
  pending: Float!
  public: Float!
  availableToUser: Float!
  readByUser: Float!
}

"""Message posted by an Admin for the event audience"""
type EventMessage {
  id: String!
  eventId: String!
  subject: String!
  message: String!
  messageType: String!
  userReadReceipt: ReadReceipt
  audience: String!
  replies: [EventMessageReply!]!
  repliesCount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  author: User!
  updatedBy: User!
}

type ReadReceipt {
  id: ID!
  userId: ID!
  messageId: ID!
  readAt: String!
}

"""Replies to event messages, can be nested one level. Also using a soft delete to ensure nesting and history can be preserved"""
type EventMessageReply {
  id: String!
  eventMessageId: String!
  parentMessageId: String
  message: String!
  replies: [EventMessageReply!]!
  repliesCount: Float!
  isDeleted: Boolean!
  createdAt: DateTime!
  createdBy: User!
  updatedAt: DateTime!
  updatedBy: User!
}

union EventTiebreakTypeCombined = Tiebreak | TeamTiebreak

type TeamTiebreak {
  id: ID!
  place: Float!
  eventTeamId: ID!
  eventTeam: TeamPlayer!
}

union EventTiesTypeCombined = Tie | TeamTie

type Tie {
  eventId: ID!
  divisionId: ID!
  place: Float!
  score: Float
  players: [Player!]!
  event: Event!
  division: Division!
}

type TeamTie {
  eventId: ID!
  divisionId: ID!
  place: Float!
  score: Float
  teams: [TeamPlayer!]!
  event: Event!
  division: Division!
}

type RegistrationStage {
  id: ID!
  date: DateTime!
  active: Boolean!
  criterias: [RegistrationCriteria]!
  division: Division!
}

type RegistrationCriteria {
  id: ID!
  type: RegistrationCriteriaType!
  value: String
}

enum RegistrationCriteriaType {
  OPEN_FOR_ALL
  MIN_PDGA_RATING
  MAX_PDGA_RATING
  PDGA_NUMBER
}

union EventLeaderboardDivisionCombined = EventLeaderboardDivision | EventLeaderboardDivisionTeam

type EventLeaderboardDivision {
  id: ID!
  name: String!
  type: String!
  players: [EventLeaderboardPlayer!]!
  totalPlayers: Float!
}

type EventLeaderboardPlayer {
  place: Float!
  playerId: ID!
  userId: ID!
  profileImageUrl: String
  firstName: String!
  lastName: String!
  pdgaNumber: Float
  pdgaRating: Float
  isDnf: Boolean!
  isDns: Boolean!
  score: Float
  par: Float
  points: Float
  poolLeaderboards: [EventLeaderboardPool!]!
  penalties: [EventPlayerPenalty]!
  boons: [EventPlayerBoon]!
}

type EventLeaderboardPool {
  place: Float!
  score: Float
  par: Float
  points: Float
  poolId: ID!
  penalties: [EventPlayerPenalty]!
}

type EventLeaderboardDivisionTeam {
  id: ID!
  name: String!
  type: String!
  players: [EventLeaderboardTeamPlayer!]!
  totalPlayers: Float!
}

type EventLeaderboardTeamPlayer {
  eventTeamId: ID!
  place: Float!
  team: Team!
  dnfDns: String
  isDnfDns: Boolean
  score: Float
  par: Float
  points: Float
  poolTeamLeaderboards: [EventTeamLeaderboardPool!]!
  penalties: [EventPlayerPenalty]!
  boons: [EventPlayerBoon]!
}

type EventTeamLeaderboardPool {
  place: Float!
  score: Float
  par: Float
  points: Float
  poolId: ID!
  penalties: [EventPlayerPenalty]!
}

type GeneralOrderType {
  free: [FreeOrder]
  paid: [Order]
}

"""Information about free order."""
type FreeOrder {
  id: ID!
  eventId: ID!
  user: User!
  lineItems: [FreeLineItem]!
  registration: Registration
  comment: String
  createdAt: DateTime!
}

"""Free Line Item of Order"""
type FreeLineItem {
  id: ID!
  orderId: ID!
  shopItem: ShopItem!
  quantity: Int!
  isDelivered: Boolean!
}

enum OrderContentType {
  ALL
  ITEM
  REGISTRATION
}

union UserEventMetaTypeCombined = EventUserMeta | EventTeamMeta

"""Meta information about the user in this event."""
type EventUserMeta {
  groups: [Group]!
  registration: Registration
  favourite: FavouriteEvent
  tjingEventRating: Float
  eventGameScorecards: [EventGameScorecard]!
}

"""Information about an event game"""
type EventGameScorecard {
  id: ID!
  gameStationLayoutId: ID!
  gameStationLayout: EventGameStationLayout!
  round: EventGameRound!
  players: [EventGameScorecardUser]!
  status: EventGameScorecardStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGameStationLayout {
  id: ID!
  name: String!
  type: EventGameCategory!
  stations: [EventGameStation!]!
  createdBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGameStation {
  id: ID!
  eventGameStationLayoutId: ID!
  eventGameStationLayout: EventGameStationLayout!
  position: Float!
  name: String!
  attempts: Float!
  attemptsCounted: Float!
  pointsAwardedPerAttempt: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGameRound {
  id: ID!
  gameId: ID!
  game: EventGame!
  gameStationLayoutId: ID
  automaticallyAssignPlayers: Boolean!
  gameStationLayout: EventGameStationLayout
  date: DateTime!
  status: EventGameRoundStatus!
  scorecards(userId: ID): [EventGameScorecard]!
  leaderboard: [EventGameRoundLeaderboardDivision]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGame {
  id: ID!
  eventId: ID!
  event: Event!
  position: Float!
  type: EventGameCategory!
  name: String!
  description: String
  automaticallyAddPlayers: Boolean!
  rounds: [EventGameRound]!
  players: [EventGamePlayer]!
  playersCount: Float!
  leaderboard(divisionId: ID): GameEventLeaderboardDivision
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGamePlayer {
  id: ID!
  gameId: ID!
  game: EventGame!
  eventPlayerId: ID!
  eventPlayer: Player!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GameEventLeaderboardDivision {
  id: ID!
  name: String!
  type: String!
  players: [GameEventLeaderboardPlayer!]!
  totalPlayers: Float!
}

type GameEventLeaderboardPlayer {
  place: Float!
  gamePlayerId: ID!
  userId: ID!
  profileImageUrl: String
  firstName: String!
  lastName: String!
  pdgaNumber: Float
  pdgaRating: Float
  score: Float!
}

enum EventGameRoundStatus {
  CLOSED
  OPEN
  COMPLETED
}

type EventGameRoundLeaderboardDivision {
  id: ID!
  name: String!
  type: String!
  players: [EventGameRoundLeaderboardPlayer!]!
  totalPlayers: Float!
}

type EventGameRoundLeaderboardPlayer {
  userId: ID!
  gamePlayerId: ID!
  eventPlayerId: ID!
  scorecardUserId: ID!
  place: Float!
  firstName: String!
  lastName: String!
  profileImageUrl: String
  pdgaNumber: Float
  pdgaRating: Float
  score: Float
  results: [EventGameRoundLederboardResult]!
}

type EventGameRoundLederboardResult {
  stationId: ID!
  score: Float!
  attempts: [EventGameScorecardAttempt]!
}

"""Information about an event game"""
type EventGameScorecardAttempt {
  id: ID!
  score: Float!
  attemptNumber: Float!
  stationId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGameScorecardUser {
  id: ID!
  attempts: [EventGameScorecardAttempt]!
  eventGameUser: EventGamePlayer!
  user: User!
  results: [EventGameScorecardResult]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Information about an event game"""
type EventGameScorecardResult {
  id: ID!
  score: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum EventGameScorecardStatus {
  CLOSED
  OPEN
  COMPLETED
}

"""Meta information about the users team in this event."""
type EventTeamMeta {
  groups: [Group]!
  registrations: [TeamRegistration]!
  favourite: FavouriteEvent
  tjingEventRating: Float
}

type DivisionInPoolType {
  poolId: ID!
  divisionId: ID!
}

"""Question asked players registering to an event."""
type RegistrationQuestion {
  id: ID!
  eventId: ID!
  position: Float!
  question: String!
  questionType: RegistrationQuestionVariant!
  mandatory: Boolean!
  options: [RegistrationQuestionOption]!
  exclusiveToDivisions: [Division]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RegistrationQuestionVariant {
  FREE_TEXT
  MULTI_ANSWER
  MULTI_CHOICE
}

"""Country restrictions for this event, primarily used in the registration process"""
type EventCountryRestriction {
  id: ID!
  eventId: ID
  countryCode: CountryCode
  countryName: String
  isBlackList: Boolean
}

union UserRegistrationsCombined = Registration | TeamRegistration

input RegistrationFilterMetaInput {
  operator: FilterOperator = AND
  query: [RegistrationFilterInput!]!
}

enum FilterOperator {
  OR
  AND
}

input RegistrationFilterInput {
  status: RegistrationStatus
  before: DateTime
  after: DateTime
}

input PoolFilterMetaInput {
  operator: FilterOperator = AND
  query: [PoolFilterInput!]!
}

input PoolFilterInput {
  status: PoolStatus!
}

input GroupsFilterInput {
  operator: FilterOperator = AND
  query: [GroupsFilterMetaInput!]!
}

input GroupsFilterMetaInput {
  operator: FilterOperator = AND
  groupStatus: GroupStatus
  poolStatus: PoolStatus
}

"""Information about disc storage"""
type DiscStorage {
  id: ID!
  type: DiscStorageType
  discs: [Disc]!
  updatedAt: DateTime!
  createdAt: DateTime!
}

enum DiscStorageType {
  BAG
  FOR_SALE
  STORAGE
  TROPHY_CASE
}

input ScorecardFilterMetaInput {
  operator: FilterOperator = AND
  query: [ScorecardFilterInput!]!
}

input ScorecardFilterInput {
  status: ScorecardStatus!
}

"""Information about subscription"""
type SubscriptionWithPackage {
  id: String!
  subscriptionId: String
  status: String!
  recurrence: Recurrence!
  currentPeriodStart: Int
  currentPeriodEnd: Int
  startDate: Int
  endDate: Int
  cancelDate: Int
  monthlyFee: String
  yearlyFee: String
  currency: String
  tier: PackageTierEnum
}

enum Recurrence {
  MONTHLY
  ANNUALLY
}

"""Information about a specific friendship request"""
type FriendshipRequest {
  id: ID!
  senderUser: User!
  receiverUser: User!
  updatedAt: DateTime!
  createdAt: DateTime!
}

"""Information about a friendship between two users"""
type Friendship {
  id: ID!
  friendUser: User!
  isBlocked: Boolean!
  note: String
  pushNotificationsEnabled: Boolean!
  blockedByUser: User
  updatedAt: DateTime!
  createdAt: DateTime!
}

union ActivityUnion = FriendsEventRound | FriendsCasualRound

type FriendsEventRound {
  user: User!
  userId: ID!
  poolId: ID!
  roundId: ID!
  eventId: ID!
  courseId: ID
  courseName: String
  layoutName: String!
  layoutId: ID!
  layoutVersionId: ID!
  layoutPar: Float!
  date: DateTime!
  totalThrows: Float!
  totalPar: Float!
}

type FriendsCasualRound {
  user: User!
  userId: ID!
  scorecardId: ID!
  courseId: ID
  courseName: String
  layoutName: String!
  layoutId: ID!
  layoutVersionId: ID!
  layoutPar: Float!
  date: DateTime!
  totalThrows: Float!
  totalPar: Float!
}

input ToursFilterInput {
  operator: FilterOperator = AND
  query: [ToursFilterMetaInput!]!
}

input ToursFilterMetaInput {
  operator: FilterOperator = AND
  status: TourStatus
}

"""Information about Event Search"""
type EventSearchResultType {
  numberOfResults: Int!
  resultsPerPage: Int!
  results: [EventSearchType!]!
}

"""Information about Event"""
type EventSearchType {
  id: ID!
  name: String!
  singles: Boolean!
  teamSize: Float!
  category: EventCategoryEnum!
  gameType: EventGameCategory!
  startDate: DateTime!
  endDate: DateTime!
  registrationOpenAt: DateTime
  registrationCloseAt: DateTime
  isRegistrationOpen: Boolean!
  cityName: String
  cityCounty: String
  cityCountry: String
  cityGeolocation: Geolocation
  tourName: String
  tourType: String
  pdgaType: String
  rounds: [EventRoundSearchType]!
}

"""Information about Event Round"""
type EventRoundSearchType {
  pools: [EventRoundPoolSearchType]!
}

"""Information about Event Round Pool"""
type EventRoundPoolSearchType {
  date: String
  courseName: String
  courseGeolocation: Geolocation
}

input EventSearchDateInputType {
  from: DateTime
  to: DateTime
}

enum EventSearchSortInputType {
  DATE
  DISTANCE
}

input EventSearchDistanceInputType {
  geolocation: GeolocationInput!
  maxDistance: Float
}

input GeolocationInput {
  lng: Float!
  lat: Float!
}

enum EventPlayersOrderByInput {
  firstName
  pdgaNumber
  pdgaRating
  createdAt
  onSite
}

enum EventRegistrationsOrderByInput {
  firstName
  pdgaNumber
  pdgaRating
  createdAt
}

enum EventTeamsOrderByInput {
  firstName
  pdgaNumber
  pdgaRating
  createdAt
  onSite
}

input NameAndDistanceInput {
  search: String
  geolocation: GeolocationInput
}

"""Information about Course"""
type SearchCourse {
  id: ID!
  name: String!
  address: String
  phone: String
  website: String
  type: CourseType
  distance: Float
  geolocation: Geolocation
  facilities: [CourseFacility]
  ratings(start: DateTime, end: DateTime): CourseLayoutRatings!
  layouts: [Layout!]!
  courseAdmins: [CourseAdministrator!]!
}

union SearchCourseCombined = SearchCourseCluster | SearchCourse

"""Information about Course"""
type SearchCourseCluster {
  courseCount: ID!
  geolocation: Geolocation
}

type EventMessageAudience {
  name: String!
  type: EventMessageAudienceEnum!
}

enum EventMessageAudienceEnum {
  PUBLIC
  ACCEPTED
  PENDING
  PERSONAL
}

type EventMessageTypeType {
  name: String!
  type: EventMessageTypeEnumType!
}

enum EventMessageTypeEnumType {
  EVENT_POST
  EVENT_MESSAGE_REPLY
  EVENT_MESSAGE_COMMENT
}

type UserPlayedLayouts {
  layouts: [UserPlayedLayout]
  totalCount: Float!
}

type UserPlayedLayout {
  courseId: ID
  courseName: String
  layoutName: String!
  layoutColor: LayoutColorType!
  layoutId: ID!
}

type CourseUserEventStats {
  userId: ID!
  numberOfCoursesPlayed: Float!
  numberOfRoundsPlayed: Float!
  numberOfLayoutsPlayed: Float!
  numberOfHolesPlayed: Float!
  totalThrows: Float!
  totalPar: Float!
  averageRound: Float!
  averagePar: Float!
  bestRound: CourseUserEventRound!
  worstRound: CourseUserEventRound!
  rounds: [CourseUserEventRound]
}

type CourseUserEventRound {
  userId: ID!
  poolId: ID!
  groupId: ID!
  roundId: ID!
  eventId: ID!
  courseId: ID
  courseName: String
  layoutName: String!
  layoutId: ID!
  layoutVersionId: ID!
  layoutPar: Float!
  date: DateTime!
  totalThrows: Float!
  totalPar: Float!
  rating: Float
}

enum CourseStatsSortBy {
  BEST
  WORST
  RECENT
  OLDEST
}

type CourseUserCasualStats {
  userId: ID!
  numberOfCoursesPlayed: Float!
  numberOfRoundsPlayed: Float!
  numberOfLayoutsPlayed: Float!
  numberOfHolesPlayed: Float!
  totalThrows: Float!
  totalPar: Float!
  averageRound: Float!
  averagePar: Float!
  bestRound: CourseUserCasualRound!
  worstRound: CourseUserCasualRound!
  rounds: [CourseUserCasualRound]
}

type CourseUserCasualRound {
  userId: ID!
  scorecardId: ID!
  courseId: ID
  courseName: String
  layoutName: String!
  layoutId: ID!
  layoutVersionId: ID!
  layoutPar: Float!
  date: DateTime!
  totalThrows: Float!
  totalPar: Float!
  rating: Float
}

"""Public information about the specified user"""
type PublicUser {
  id: ID!
  firstName: String
  lastName: String
  profile: PublicUserProfile!
  teams: [Team]!
}

"""Detailed information about a user"""
type PublicUserProfile {
  id: ID!
  club: String
  mainClubName: String
  mainClubSlug: String
  pdgaNumber: Float
  pdgaRating: Float
  country: Country
  instagram: String
  facebook: String
  twitter: String
  youtube: String
  tiktok: String
  sponsor: String
  sponsors: [UserSponsor]!
  biography: String
  profileImageUrl: String
  teeOffSongUrl: String
  isPublic: Boolean
  hasPinCode: Boolean
}

"""See more info at https://en.wikipedia.org/wiki/ISO_4217"""
type Currency {
  name: String!
  code: String!
  digits: Float!
  isEnabledForPayments: Boolean!
}

type Meta {
  apiVersion: String!
}

"""Information about subscription"""
type ManageSubscription {
  url: String!
}

"""Information about package prices"""
type PackagePrices {
  id: String!
  currency: String
  monthlyFee: Int!
  yearlyFee: Int!
  isActive: Boolean
}

type CasualRoundLeaderboardEntry {
  position: Int!
  scorecardId: ID!
  userId: ID!
  user: PublicUser!
  courseId: ID!
  courseName: String!
  layoutId: ID!
  layoutName: String!
  layoutPar: Int!
  date: DateTime!
  totalThrows: Int!
  totalPar: Int!
  rating: Float
}

enum CasualRoundsSortBy {
  RATING
  PAR
  SCORE
  DATE
}

type CompetitiveRoundLeaderboardEntry {
  position: Int!
  poolId: ID!
  userId: ID!
  user: PublicUser!
  courseId: ID!
  course: Course!
  courseName: String!
  layoutId: ID!
  layoutName: String!
  layoutPar: Int!
  date: DateTime!
  totalThrows: Int!
  totalPar: Int!
  rating: Float
  eventId: ID!
  event: Event!
}

enum CompetitiveRoundsSortBy {
  RATING
  PAR
  SCORE
  DATE
}

type RootMutation {
  AddAdministratorByEmail(tourId: ID!, email: String!, asRole: MutationUserRoleType): Administrator
  AddAdministratorById(tourId: ID!, userId: ID!, asRole: MutationUserRoleType): Administrator
  AddAnonymousUserToScorecard(name: String!, scorecardId: ID!, scoringMode: ScoringModeType): ScorecardPlayer
  AddGroupMarshall(groupId: ID!, userId: String!): Group
  AddPlayerToGroup(groupId: ID!, playerId: ID!, playerOrder: [ID!], asRole: MutationUserRoleType): Player
  AddTeamPlayerToGroup(groupId: ID!, playerId: ID!, playerOrder: [ID!], asRole: MutationUserRoleType): TeamPlayer
  AddUserToEvent(divisionId: ID!, eventId: ID!, userId: ID!, asRole: MutationUserRoleType): Player
  AddTeamToEvent(divisionId: ID!, eventId: ID!, teamId: ID!, asRole: MutationUserRoleType): TeamPlayer
  AddUserToScorecard(userId: ID!, scorecardId: ID!, scoringMode: ScoringModeType): ScorecardPlayer
  AddTeamToScorecard(teamId: ID!, scorecardId: ID!, scoringMode: ScoringModeType): ScorecardPlayer
  AcceptRegistrationInvitation(invitationId: ID!, divisionId: ID!, groupId: ID, teamId: ID): Registration
  AnonymizeAccount(userId: ID!, asRole: MutationUserRoleType, password: String): User
  CancelRegistration(registrationId: ID!): Registration
  CancelTeamRegistration(registrationId: ID!): TeamRegistration
  ChangePassword(currentPassword: String!, newPassword: String!): Boolean
  CloseGroup(groupId: ID!, confirmDnf: Boolean, asRole: MutationUserRoleType): Group
  OpenGroup(groupId: ID!, asRole: MutationUserRoleType): Group
  ConfirmEventRegistrationPayment(paymentIntentId: ID!, stripePaymentIntentId: ID!): Registration
  CreateAccount(input: CreateAccountInput!): User
  CreateAuthToken(email: String!, password: String!): AuthToken
  CreateConnectedAccount(authorizationCode: String!, name: String): StripeConnectedAccount
  CreateCourse(input: CourseInput!): Course
  CreateTeam(input: TeamInput!): Team
  UpdateTeam(teamId: ID!, input: UpdateTeamInput!): Team
  CreateTeamPlayer(input: TeamPlayerInput!): TeamPlayerType
  UpdateTeamPlayer(teamPlayerId: ID!, input: UpdateTeamPlayerInput!): TeamPlayerType
  CreateDivision(tourId: ID!, input: DivisionInput!, asRole: MutationUserRoleType): Division
  CreateEvent(tourId: ID!, input: EventInput!, asRole: MutationUserRoleType): Event
  CreateEventTiebreak(playerId: ID!, place: Float!): Tiebreak
  CreateGroup(poolId: ID!, input: GroupInput!): Group
  CreateRegistrationInvitation(eventId: ID!, type: EventRegistrationInvitationTypeType): EventRegistrationInvitation
  CreateGroupRegistrationReservation(eventId: ID!, groupId: ID!): GroupRegistrationReservation
  CreateGroups(roundId: ID!, creationMethod: RoundGroupCreationMethod!, divisionAssigment: [RoundDivisionAssigmentInput]!): Round
  CreateGroupsForPool(poolId: ID!, creationMethod: PoolGroupCreationMethod!, divisionAssigment: [DivisionAssigmentInput]!, previousPoolId: ID): Pool
  CreateLayout(courseId: ID, input: LayoutInput!): Layout
  CreateLayoutVersion(layoutId: ID!, input: CreateLayoutVersionInput!): LayoutVersion
  CreatePool(roundId: ID!, input: PoolInput!, asRole: MutationUserRoleType): Pool
  CreateResult(groupId: ID!, holeId: ID!, playerId: ID!, input: ResultInput!, asRole: MutationUserRoleType): Result
  CreateTeamResult(groupId: ID!, holeId: ID!, teamPlayerId: ID!, input: TeamResultInput!, asRole: MutationUserRoleType): TeamResult
  CreateRound(eventId: ID!, asRole: MutationUserRoleType): Round
  CreateScorecard(input: CreateScorecardInput!): Scorecard
  CreateScorecardResult(scorecardId: ID!, playerId: ID!, holeId: ID!, input: CreateScorecardResultInput!): ScorecardResult
  CreateTour(input: TourInput!): Tour
  CreateTourExtended(input: ExtendedTourInput!): Tour
  CreateTaxRate(stripeAccountId: ID!, input: CreateTaxRateInput!): TaxRate
  CreateCheckoutSession(eventId: ID!, successUrl: String!, cancelUrl: String!, input: CheckoutSessionInput!): CheckoutSession
  DeleteAdministrator(tourId: ID!, userId: ID!): Administrator
  DeleteConnectedAccount(id: ID!): StripeConnectedAccount
  DeleteDivision(divisionId: ID!): Boolean
  DeleteEvent(eventId: ID!): Boolean
  DeleteEventDocument(documentId: ID!, url: ID!): Boolean
  DeleteEventTiebreak(tiebreakId: ID!): Tiebreak
  DeleteEventTeamTiebreak(tiebreakId: ID!): Boolean
  DeleteGroup(groupId: ID!): Group
  DeleteGroups(poolId: ID!, resetPoolStatus: Boolean): Pool
  DeleteLayout(layoutId: ID!): Boolean
  DeleteLayoutVersion(layoutVersionId: ID!): Boolean
  DeletePool(poolId: ID!): Boolean
  DeleteResult(resultId: ID!): Boolean
  DeleteTeamResult(resultId: ID!): Boolean
  DeleteRound(roundId: ID!): Boolean
  DeleteScorecard(scorecardId: ID!): Boolean
  DeleteShopItem(shopItemId: ID!): Boolean
  DeleteTour(tourId: ID!): Boolean
  PublishTour(tourId: ID!, asRole: MutationUserRoleType): Tour
  RegisterToEvent(registrationItem: CreateFreeRegistrationInput!, lineItems: [CreateFreeLineItemsInput]): Registration
  RegisterTeamToEvent(registrationItem: CreateFreeTeamRegistrationInput!, lineItems: [CreateFreeTeamLineItemsInput]): TeamRegistration
  RemoveGroupMarshall(groupId: ID!): Group
  RemovePlayerFromGroup(groupId: ID!, playerId: ID!, asRole: MutationUserRoleType): Player
  RemoveTeamPlayerFromGroup(groupId: ID!, playerId: ID!, asRole: MutationUserRoleType): TeamPlayerType
  RemoveUserFromEvent(eventId: ID!, userId: ID!): Player
  RemoveUserFromScorecard(playerId: ID!, scorecardId: ID!): Boolean
  RequestPasswordReset(email: String!): Boolean
  ResetPassword(resetToken: String!, newPassword: String!): Boolean
  SendVerifyEmail: Boolean
  ShuffleStartingHoles(poolId: ID!): Pool
  SignResult(groupId: ID!, playerId: ID!, pinCode: String, asRole: MutationUserRoleType): GroupPlayerConnection
  SignTeamResult(groupId: ID!, playerId: ID!, pinCode: String, asRole: MutationUserRoleType): GroupPlayerConnection
  UnPublishTour(tourId: ID!, asRole: MutationUserRoleType): Tour
  UpdateAnonymousUser(userId: ID!, input: UpdateAnonymousUserInput!): AnonymousUser
  UpdateCourse(courseId: ID!, input: UpdateCourseInput!): Course
  UpdateDisableAccount(userId: ID!, disabled: Boolean!): User
  UpdateDivision(divisionId: ID!, input: UpdateDivisionInput!, asRole: MutationUserRoleType): Division
  UpdateEvent(eventId: ID!, input: UpdateEventInput!, asRole: MutationUserRoleType): Event
  UpdateGroup(groupId: ID!, input: UpdateGroupInput!, asRole: MutationUserRoleType): Group
  UpdateGroupStatus(groupId: ID!, status: GroupStatus!): Group
  UpdateLayout(layoutId: ID!, input: UpdateLayoutInput!): Layout
  UpdateLayoutVersion(layoutVersionId: ID!, input: UpdateLayoutVersionInput!, confirmUpdateResults: Boolean): LayoutVersion
  UpdateMeUser(input: UpdateMeUserInput!): User
  UpdatePlayer(playerId: ID!, input: UpdatePlayerInput!, asRole: MutationUserRoleType): Player
  UpdatePlayerDnf(playerId: ID!, isDnf: Boolean!, asRole: MutationUserRoleType): Player
  UpdatePlayerDns(playerId: ID!, isDns: Boolean!, asRole: MutationUserRoleType): Player
  UpdatePool(poolId: ID!, input: UpdatePoolInput!, asRole: MutationUserRoleType): Pool
  UpdatePoolStatus(poolId: ID!, status: PoolStatus!, confirmDnf: Boolean): Pool
  UpdateRegistrationInvitation(invitationId: ID!, status: EventRegistrationInvitationStatus!): EventRegistrationInvitation
  UpdateRegistration(registrationId: ID!, input: UpdateRegistrationInput!, asRole: MutationUserRoleType): Registration
  UpdateRegistrationStatus(registrationId: ID!, status: RegistrationStatus!, asRole: MutationUserRoleType): Registration
  UpdateTeamRegistrationStatus(registrationId: ID!, status: RegistrationStatus!, asRole: MutationUserRoleType): TeamRegistration
  UpdateTeamRegistration(registrationId: ID!, input: UpdateTeamRegistrationInput!, asRole: MutationUserRoleType): TeamRegistration
  UpdateResult(resultId: ID!, input: UpdateResultInput!, asRole: MutationUserRoleType): Result
  UpsertGroupScore(groupId: ID!, holeId: ID!, userGroupId: ID!, input: UpsertGroupScoreInput!): GroupScore
  UpsertTeamGroupScore(groupId: ID!, holeId: ID!, teamGroupId: ID!, input: UpsertTeamGroupScoreInput!): TeamGroupScore
  UpdateTeamResult(resultId: ID!, input: UpdateTeamResultInput!, asRole: MutationUserRoleType): TeamResult
  UpdateScorecard(scorecardId: ID!, input: UpdateScorecardInput!): Scorecard
  UpdateScorecardResult(resultId: ID!, input: UpdateScorecardResultInput!): ScorecardResult
  UpdateTour(tourId: ID!, input: UpdateTourInput!, asRole: MutationUserRoleType): Tour
  UpdateUser(userId: ID!, input: UpdateUserInput!): UserProfile
  UpdateUserPayment(eventId: ID!, userId: ID!, hasPaid: Boolean!): Boolean
  UpdateTeamPayment(eventId: ID!, teamId: ID!, hasPaid: Boolean!): Boolean
  UpdateVerifyResult(resultId: ID!, isVerified: Boolean!, resultHash: String!, asRole: MutationUserRoleType): Result
  UpdateVerifyTeamResult(resultId: ID!, isVerified: Boolean!, resultHash: String!, asRole: MutationUserRoleType): Result
  UpdateTaxRate(taxId: ID!, input: UpdateTaxRateInput!): TaxRate
  UpdateShopItem(shopItemId: ID!, input: UpdateShopItemInput!): ShopItem
  UpdateOrder(orderId: ID!, input: UpdateOrderInput!): Boolean
  UpdateLineItem(lineItemId: ID!, input: UpdateLineItemInput!): Boolean
  UpdateEventDocument(documentId: ID!, input: EventDocumentUpdateInput!): Boolean
  ValidateAppVersion(appVersion: String!, apiVersion: String!, devicePlatform: DevicePlatformType!): Boolean
  VerifyEmail(token: ID!): Me
  CreateRegistrationStage(eventId: ID!, divisionId: ID!, input: CreateRegistrationStageInput!): RegistrationStage
  CreateRegistrationCriteria(registrationStageId: ID!, input: CreateRegistrationCriteriaInput!): RegistrationCriteria
  DeleteRegistrationStage(registrationStageId: ID!): Boolean
  UpdateRegistrationStage(registrationStageId: ID!, input: UpdateRegistrationStageInput!): RegistrationStage
  UpdateRegistrationCriteria(registrationCriteriaId: ID!, input: UpdateRegistrationCriteriaInput!): RegistrationCriteria
  DeleteRegistrationCriteria(registrationCriteriaId: ID!): Boolean
  CreateCourseFacility(courseId: ID!, input: CourseFacilityInput!): CourseFacility
  DeleteCourseFacility(facilityId: ID!): Boolean
  AddCourseAdmin(courseId: ID!, userEmail: String!, role: CourseAdministratorRole!): CourseAdministrator
  RemoveCourseAdmin(courseId: ID!, userId: ID!): Boolean
  CreateHoleUserNote(holeId: ID!, note: String!): HoleUserNote
  DeleteHoleUserNote(noteId: ID!): Boolean
  UpdateHole(holeId: ID!, input: UpdateHoleInput!): Hole
  CreateEventMessage(eventId: ID!, input: CreateEventMessageInput!): EventMessage
  UpdateEventMessage(messageId: ID!, input: UpdateEventMessageInput!): EventMessage
  DeleteEventMessage(messageId: ID!): Boolean
  CreateEventMessageReadReceipt(messageId: ID!): ReadReceipt
  DeleteEventMessageReadReceipt(messageId: ID!): Boolean
  CreateEventMessageReply(eventMessageId: ID!, parentMessageId: ID, message: String!): EventMessageReply
  UpdateEventMessageReply(eventMessageReplyId: ID!, isDeleted: Boolean!): EventMessageReply
  RegisterDevice(deviceToken: String!, platform: RegisteredDevicePlatform!, appVersion: String): RegisteredDevice
  DeleteRegisteredDevice(deviceToken: String!): Boolean
  CreateEventFavourite(eventId: ID!): FavouriteEvent
  DeleteFavouriteEvent(favouriteId: ID!): Boolean
  ShopCreateItem(eventId: ID!, input: ShopItemInput!, asRole: MutationUserRoleType): ShopItem
  Refund(orderId: ID!, amount: Int!): Boolean
  UpdateRegistrationLineItem(orderId: ID!, refundStatus: Boolean!): Boolean
  CreateSubscription(successUrl: String!, cancelUrl: String!, currency: String!, tier: PackageTierEnum!, recurrence: RecurrenceEnum!): Subscription
  UpdateUserTourPassMutation(tourPaymentId: ID!, divisionTourPassId: ID!, tourPaymentVariant: TourPaymentVariant!, updateExistingRegistrations: Boolean): TourPass
  ReindexElasticSearch: ReindexElasticSearch
  ReindexElasticSearchEvent(eventId: ID!): ReindexElasticSearch
  UpdateGroupPlayerOrder(groupId: ID!, playerOrder: [ID!]!): Boolean
  UpdateGroupOrder(poolId: ID!, groupsOrder: [ID!]!): Boolean
  CreateCourseLayoutReview(layoutId: ID!, layoutVersionId: ID!, input: CreateCourseLayoutReviewInput!): CourseLayoutReview
  UpdateCourseLayoutReview(reviewId: ID!, input: UpdateCourseLayoutReviewInput!): CourseLayoutReview
  DeleteCourseLayoutReview(reviewId: ID!): Boolean
  CreateTransferTourOwnership(email: String!, tourId: String!): TransferTourOwnershipType
  CancelTransferTourOwnership(transferId: ID!): TransferTourOwnershipType
  AcceptRejectTransferTourOwnership(token: String!, status: TourTransferStatus!): TransferTourOwnershipType
  CreateDivisionOverride(eventId: ID!, divisionId: ID!, input: CreateEventDivisionOverrideInput!): EventDivisionOverride
  UpdateDivisionOverride(eventRegistrationFeeId: ID!, input: UpdateEventDivisionOverrideInput!): EventDivisionOverride
  DeleteDivisionOverride(divisionOverrideId: ID!): Boolean
  CreateFreeOrder(eventId: ID!, lineItems: [CreateFreeOrderInputType]!): FreeOrder
  CreateOrganization(input: OrganizationInput!): Organization
  UpdateOrganization(organizationId: String!, input: UpdateOrganizationInput!): Organization
  DeleteOrganization(organizationId: String!): Boolean
  AddOrganizationAdministrator(organizationId: ID!, userId: ID!, asRole: OrganizationAdministrationRole): OrganizationAdministrator
  RemoveOrganizationAdministrator(organizationId: ID!, userId: ID!): Boolean
  CreateOrganizationMemberType(input: OrganizationMemberTypeInput!): OrganizationMemberType
  UpdateOrganizationMemberType(input: UpdateOrganizationMemberTypeInput!): OrganizationMemberType
  CreateOrganizationMember(membershipTypeId: ID!): OrganizationMember
  UpdateOrganizationMember(membershipId: ID!, asRole: UpdateOrganizationMemberRoleType!, input: UpdateOrganizationMemberInput!): OrganizationMember
  DeleteOrganizationMember(membershipId: String!, asRole: DeleteOrganizationMemberRole!): Boolean
  CreateOrganizationCourseRelation(organizationId: ID!, courseId: ID!, relationType: OrganizationCourseRelationType!): OrganizationCourseRelation
  DeleteOrganizationCourseRelation(courseRelationId: ID!): Boolean
  CreateOrganizationContent(organizationId: ID!, input: OrganizationContentInput!): OrganizationContent
  UpdateOrganizationContent(contentId: ID!, input: UpdateOrganizationContentInput!): Organization
  DeleteOrganizationContent(contentId: ID!): Boolean
  DeleteOrganizationContentDocument(documentId: ID!, url: ID!): Boolean
  CreateMembershipCheckoutSession(successUrl: String!, cancelUrl: String!, membershipItem: CreateMembershipInput!): CheckoutSession
  CreateRegistrationQuestion(eventId: ID!, input: RegistrationQuestionInputType!): RegistrationQuestion
  UpdateRegistrationQuestion(questionId: ID!, input: UpdateRegistrationQuestionInputType!): RegistrationQuestion
  DeleteRegistrationQuestion(questionId: ID!): Boolean
  CreateRegistrationQuestionResponse(questionId: ID!, value: String, options: [String]): RegistrationQuestion
  CreateDisc(input: CreateDiscInput!, storageId: ID): Disc
  UpdateDisc(discId: ID, input: UpdateDiscInput!): Disc
  DeleteDisc(discId: ID!): Boolean
  CreateThrows(holeId: ID!, scorecardPlayerId: ID, groupPlayerId: ID, groupTeamPlayerId: ID, input: [CreateThrowsInput!]!): [Throw]
  UpdateThrow(throwId: ID!, input: UpdateThrowInput!): Throw
  DeleteThrow(throwId: ID!): Boolean
  ContactCourseGuardian(courseId: ID!, message: String!): Boolean
  AddTourOrganizer(tourId: ID!, organizationId: ID!): Boolean
  RemoveTourOrganizer(organizationId: ID!, tourId: ID!): Boolean
  CreateOrganizationOfficial(organizationId: ID!, email: String!, input: CreateOrganizationRoleInput!): OrganizationOfficialType
  UpdateOrganizationOfficial(officialId: ID!, email: String, input: UpdateOrganizationRoleInput!): OrganizationOfficialType
  DeleteOrganizationOfficial(officialId: ID!): Boolean
  UpdateOrganizationConnectionStatus(organizationId: String!, connectionStatus: OrganizationConnectionStatusType!): Organization
  CreateCustomLeaderboardSystem(tourId: ID!, input: CreateEventPointsMapInput!): EventCustomPointsMap
  UpdateCustomLeaderboardSystem(systemId: ID!, input: UpdateEventPointsMapInput!): EventCustomPointsMap
  DeleteLeaderboardPointsMap(systemId: ID!): Boolean
  MoveAllPlayersBetweenGroups(sourceGroupId: ID!, targetGroupId: ID!): Boolean
  SwapPlayersBetweenGroups(sourcePlayerId: ID!, sourceGroupId: ID!, targetPlayerId: ID, targetGroupId: ID!): Boolean
  SwapTeamsBetweenGroups(sourceTeamPlayerId: ID!, sourceGroupId: ID!, targetTeamPlayerId: ID, targetGroupId: ID!): Boolean
  CreateEventCountryRestriction(eventId: ID!, countryCode: CountryCode!, isBlacklist: Boolean!): EventCountryRestriction
  DeleteEventCountryRestriction(countryRestrictionId: ID!): Boolean
  CreateOrganizationLeaderboard(input: OrganizationLeaderboardInput!): OrganizationLeaderboard
  UpdateOrganizationLeaderboard(leaderboardId: ID!, input: OrganizationLeaderboardUpdateInput!): OrganizationLeaderboard
  DeleteOrganizationLeaderboard(leaderboardId: String!): Boolean
  AddEventsToOrganizationLeaderboard(leaderboardId: ID!, eventIds: [ID!]!): Boolean
  RemoveEventsFromOrganizationLeaderboard(leaderboardId: ID!, eventIds: [ID!]!): Boolean
  AddBestOfToOrganizationLeaderboard(leaderboardId: ID!, tourConfigs: [LeaderboardTourConfig!]!): Boolean
  UpdateBestOfToOrganizationLeaderboard(leaderboardConfigId: ID!, scoreBasedOnNumberOfEvents: Float!): OrganizationLeaderboardConfiguration
  DeleteBestOffFromOrganizationLeaderboard(leaderboardConfigId: ID!): Boolean
  CreateUserSponsor(input: UserSponsorInput!): UserSponsor
  UpdateUserSponsor(sponsorId: ID!, input: UpdateUserSponsorInput!): UserSponsor
  DeleteUserSponsor(sponsorId: ID!): Boolean
  UpdateScorecardUser(playerId: ID!, scorecardId: ID!, scoringMode: ScoringModeType!): ScorecardPlayer
  CreateEventPlayerPenalty(eventId: ID!, input: CreateEventPenaltyInput!): EventPlayerPenalty
  UpdateEventPlayerPenalty(penaltyId: ID!, input: UpdateEventPenaltyInput!): EventPlayerPenalty
  DeleteEventPlayerPenalty(penaltyId: ID!): Boolean
  CreateEventPlayerBoon(eventId: ID!, input: CreateEventBoonInput!): EventPlayerBoon
  UpdateEventPlayerBoon(id: ID!, par: Float, score: Float, points: Float, onlyApplicableForTour: Boolean, icon: BoonIcon, reason: String): EventPlayerBoon
  DeleteEventPlayerBoon(boonId: ID!): Boolean
  RequestEmailChange(currentPassword: String!, newEmail: String!): Boolean
  ChangeEmail(emailToken: String!): Boolean
  CreateRandomEventTeams(eventId: ID!, input: [TeamConfigurationInput]!): Boolean
  DeleteRandomEventTeams(eventId: ID!): Boolean
  CreateEventGame(eventId: ID!, input: CreateEventGameInput): EventGame
  UpdateEventGame(eventGameId: ID!, input: UpdateEventGameInput!): EventGame
  DeleteEventGame(eventGameId: ID!): Boolean
  CreateEventGameRound(eventGameId: ID!, input: CreateEventGameRoundInput): EventGame
  UpdateEventGameRound(eventGameRoundId: ID!, input: UpdateEventGameRoundInput!): EventGameRound
  DeleteEventGameRound(eventGameRoundId: ID!): Boolean
  CreateEventGamePlayers(eventGameId: ID!, eventUserIds: [ID!]!): [EventGamePlayer]
  DeleteEventGamePlayers(eventGameId: ID!, gamePlayerIds: [ID!]!): Boolean
  CreateEventGameStationLayout(name: String!, type: EventGameCategory!, stations: [CreateEventGameStationInput]!): EventGameStationLayout!
  CreateEventGameScorecardAttempt(eventGameScorecardUserId: ID!, score: Float!, eventGameStationId: ID!, attemptNumber: Float!): EventGameScorecardAttempt
  UpdateEventGameScorecardAttempt(attemptId: ID!, score: Float!): EventGameScorecardAttempt
  DeleteEventGameScorecardAttempt(attemptId: ID!): Boolean
  UpdateEventGameScorecard(gameScorecardId: ID!, status: EventGameScorecardStatus!): EventGameScorecard
  CreateEventGameRoundPlayers(eventGameRoundId: ID!, eventGamePlayerIds: [ID!]!): [EventGamePlayer]
  RemoveEventGameRoundPlayers(scorecardUserIds: [ID!]!): Boolean
  CreateTourPass(input: CreateTourPassInput!): TourPass
  UpdateTourPass(id: ID!, input: UpdateTourPassInput!): TourPass
  DeleteTourPass(id: ID!): Boolean
  PurchaseTourPass(input: PurchaseTourPassInput!, successUrl: String!, cancelUrl: String!): CheckoutSession
  RecalculatePoolRatings(poolId: ID!): Pool
  CreateFriendshipRequest(receiverUserId: ID!): FriendshipRequest
  AcceptRejectFriendshipRequest(friendshipRequestId: ID!, acceptRequest: Boolean!, cancelRequest: Boolean): Boolean
  UpdateFriendship(friendshipId: ID!, input: UpdateFriendshipInput!): Boolean
  RemoveFriendship(friendshipId: ID!): Boolean
  GenerateEventGalleryUploadParams(eventId: ID!): SignedUploadParams
  UpdateEventGalleryImage(uploadToken: String!, imageUrl: String!, description: String): EventGalleryImage
  UpdateEventGalleryImageAdmin(id: ID!, status: GalleryImageStatus, description: String): EventGalleryImage
  DeleteEventGalleryImage(id: ID!): Boolean
  RefreshPdgaData: RefreshPdgaDataResponse
  UpdatePremiumSubscriptionStatus: Boolean
}

"""In what role the mutation should run as.
  If the role-check fails an NOT_AUTHORIZED error will be returned"""
enum MutationUserRoleType {
  USER
  TOUR_ADMIN
  SUPER_ADMIN
  GROUP_MARSHALL
}

input CreateAccountInput {
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  pdgaNumber: Float
  club: String
  country: CountryCode
  phone: String
  pinCode: String
}

"""Token is used in Authorization header to authenticate"""
type AuthToken {
  userId: ID!
  token: String!
  expireAt: DateTime!
}

input CourseInput {
  name: String!
  address: String
  phone: String
  website: String
  type: CourseType
  geolocation: GeolocationInput
  description: String
  access: CourseAccessType
  feeInformation: String
}

input TeamInput {
  name: String!
  type: TeamType
  teamPlayers: [TeamPlayerInputByTeam]!
}

input TeamPlayerInputByTeam {
  fk_user_id: String!
}

input UpdateTeamInput {
  name: String
  archived: Boolean
  active: Boolean
  type: TeamType
}

input TeamPlayerInput {
  userId: String!
  teamId: String!
  status: TeamPlayerStatusType
}

input UpdateTeamPlayerInput {
  status: TeamPlayerStatusType
}

input DivisionInput {
  type: String!
  taxRateId: ID
  maxSpots: Float
  reservedSpots: Float
  maxRegistrations: Float
  registrationFee: Float
  membershipRegistrationFee: Float
  tourPassFee: Float
  membershipTourPassFee: Float
  customDivision: CustomDivisionInput
  isAgeRestricted: Boolean
  isGenderLocked: Boolean
  refundPercentage: Float
}

input CustomDivisionInput {
  customType: String
  customName: String
}

input EventInput {
  name: String!
  description: String
  maxSpots: Float
  maxRegistrations: Float
  maxWildcards: Float
  minGroupStartSize: Float
  registrationMethod: RegistrationMethod!
  registrationOpenAt: DateTime
  registrationCloseAt: DateTime
  tournamentDirectorName: String
  assistantTournamentDirectorName: String
  assistantTournamentDirectorPhone: String
  assistantTournamentDirectorEmail: String
  phone: String
  email: String
  registrationFeesInfo: String
  paymentInfo: String
  location: String
  website: String
  isVerifyMode: Boolean
  ratingEnabled: Boolean
  groupSize: Float
  isResultSigningEnabled: Boolean
  multipleScorecardModeEnabled: Boolean
  connectedAccountId: ID
  cityId: ID
  geolocation: GeolocationInput
  checkInStartsAt: DateTime
  checkInEndsAt: DateTime
  autoOpenRegistration: Boolean
  autoConfirmRegistrations: Boolean
  singles: Boolean!
  scoringAs: ScoringAs!
  defaultToTeamName: Boolean
  teamSize: Float
  autoCloseInactivePools: Boolean
  pdgaEventId: String
  pdgaType: PdgaEventTypeEnum
  waitinglistType: WaitingListTypeEnum
  agreementName: String
  agreementUrl: String
  requireOfficialStatus: Boolean
  requireOrganizationMembership: Boolean
  type: EventCategoryEnum
}

input GroupInput {
  startHoleId: ID!
  startsAt: DateTime
}

enum RoundGroupCreationMethod {
  """Creates groups without adding any players"""
  GROUPS_ONLY
  """Players are added to groups by random"""
  RANDOM
  """Players are added to groups by random within their
      respective division."""
  RANDOM_WITHIN_DIVISION
  """Players are added to groups ordered by score and by division. This can not be used on round 1"""
  SCOREANDDIVISION
}

input RoundDivisionAssigmentInput {
  poolId: ID!
  divisionId: ID!
  numberOfPlayers: Float!
}

enum PoolGroupCreationMethod {
  """Creates groups without adding any players"""
  GROUPS_ONLY
  """Players are added to groups by random"""
  RANDOM
  """Players are added to groups by random within their respective divisions"""
  RANDOM_WITHIN_DIVISION
  """Players are added to groups ordered by score and by division"""
  SCOREANDDIVISION
  """Players are added to same groups as past round. This can not be used on round 1"""
  SAME_GROUPS
}

input DivisionAssigmentInput {
  divisionId: ID!
  numberOfPlayers: Float!
}

input LayoutInput {
  name: String!
  holes: [HoleInput]!
  type: CourseType
  description: String
  dogFriendly: Boolean
  wheelchairAccessible: Boolean
  strollerAccessible: Boolean
  cartAccessible: Boolean
  color: LayoutColorType
  payToPlay: Boolean
}

input HoleInput {
  number: Float!
  par: Float!
  name: String
  length: Float
  measureInMeters: Boolean
  geolocation: [GeolocationInput]
  note: String
  hasOb: Boolean
  hasHazard: Boolean
  hasMandatory: Boolean
  hasLocalRule: Boolean
}

input CreateLayoutVersionInput {
  holes: [HoleInput]!
}

input PoolInput {
  date: DateTime!
  endDate: DateTime
  layoutVersionId: ID
  startMethod: PoolStartMethod
  playFormat: PoolPlayFormat
  areGroupsPublic: Boolean
}

input ResultInput {
  score: Float!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean!
  penaltyStrokes: Int
}

type TeamResult {
  id: ID!
  score: Float!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean!
  penaltyStrokes: Float!
  createdByUserId: ID!
  hash: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdByUser: User!
  updatedByUserId: ID!
  updatedByUser: User!
  isVerified: Boolean!
  verifiedByUserId: ID
  verifiedByUser: User
  teamPlayerConnection: GroupTeamPlayerConnection!
  hole: Hole!
}

input TeamResultInput {
  score: Float!
  isCircleHit: Boolean!
  isOutsidePutt: Boolean!
  isInsidePutt: Boolean!
  isOutOfBounds: Boolean!
  penaltyStrokes: Float
}

input CreateScorecardInput {
  date: DateTime!
  layoutVersionId: ID!
  startHoleId: ID!
  playFormat: ScorecardPlayFormat
  name: String
}

input CreateScorecardResultInput {
  score: Float!
  isTapIn: Boolean
  isCircleHit: Boolean
  isOutsidePutt: Boolean
  isInsidePutt: Boolean
  isOutOfBounds: Boolean
  penaltyStrokes: Float
}

input TourInput {
  name: String!
  scoringType: ScoringType
  scoreBasedOnNrOfEvents: Float
  paymentType: TourPaymentType
  connectedAccountId: ID
  automaticRefunds: Boolean
  type: String
  allowRegistrationMessage: Boolean
  feeIncluded: Boolean
  currency: String
}

input ExtendedTourInput {
  name: String!
  scoringType: ScoringType
  scoreBasedOnNrOfEvents: Float
  paymentType: TourPaymentType
  connectedAccountId: ID
  automaticRefunds: Boolean
  type: String
  events: [ExtendedEventInput!]
  divisions: [DivisionInput!]
  allowRegistrationMessage: Boolean
  feeIncluded: Boolean
  currency: String
}

input ExtendedEventInput {
  name: String!
  description: String
  maxSpots: Float
  maxRegistrations: Float
  maxWildcards: Float
  defaultToTeamName: Boolean
  singles: Boolean!
  scoringAs: ScoringAs!
  teamSize: Float
  rounds: [RoundInput!]
  registrationOpenAt: DateTime
  registrationCloseAt: DateTime
  tournamentDirectorName: String
  assistantTournamentDirectorName: String
  assistantTournamentDirectorPhone: String
  assistantTournamentDirectorEmail: String
  phone: String
  email: String
  registrationFeesInfo: String
  paymentInfo: String
  location: String
  website: String
  isVerifyMode: Boolean
  isResultSigningEnabled: Boolean
  ratingEnabled: Boolean
  multipleScorecardModeEnabled: Boolean
  groupSize: Float
  connectedAccountId: ID
  cityId: ID
  geolocation: GeolocationInput
  checkInStartsAt: DateTime
  checkInEndsAt: DateTime
  autoOpenRegistration: Boolean
  autoCloseInactivePools: Boolean
  autoConfirmRegistrations: Boolean
  pdgaEventId: String
  pdgaType: PdgaEventTypeEnum
  waitinglistType: WaitingListTypeEnum
  agreementName: String
  agreementUrl: String
  registrationMethod: RegistrationMethod
  requireOfficialStatus: Boolean
  requireOrganizationMembership: Boolean
  type: EventCategoryEnum
}

input RoundInput {
  pools: [PoolInput!]
}

input CreateTaxRateInput {
  name: String!
  percentage: Float!
  inclusive: Boolean = false
  description: String
}

"""Information about checkout session"""
type CheckoutSession {
  id: String!
  url: String!
  success_url: String!
  cancel_url: String!
  amount_total: Int!
  amount_subtotal: Int!
  amount_tax: Int!
  payment_status: String!
  payment_intent: String!
}

input CheckoutSessionInput {
  registration: CreateRegistrationInput
  lineItems: [CreateLineItemsInput]
  teamId: ID
}

input CreateRegistrationInput {
  divisionId: ID!
  groupId: ID
  message: String
  includeTourPass: Boolean = false
  tourPassId: ID
  teamId: ID
  questionResponses: [CreateRegistrationQuestionResponseInput]
}

input CreateRegistrationQuestionResponseInput {
  questionId: ID!
  value: String
  optionIds: [ID]
}

input CreateLineItemsInput {
  shopItemId: ID!
  quantity: Int!
}

input CreateFreeRegistrationInput {
  eventId: ID!
  divisionId: ID!
  groupId: ID
  message: String
  questionResponses: [CreateFreeRegistrationQuestionResponseInput]
}

input CreateFreeRegistrationQuestionResponseInput {
  questionId: ID!
  value: String
  optionIds: [ID]
}

input CreateFreeLineItemsInput {
  shopItemId: ID!
  quantity: Int!
}

input CreateFreeTeamRegistrationInput {
  eventId: ID!
  divisionId: ID!
  teamId: ID!
  groupId: ID
  message: String
  questionResponses: [CreateFreeTeamRegistrationQuestionResponseInput]
}

input CreateFreeTeamRegistrationQuestionResponseInput {
  questionId: ID!
  value: String
  optionIds: [ID]
}

input CreateFreeTeamLineItemsInput {
  shopItemId: ID!
  quantity: Int!
}

input UpdateAnonymousUserInput {
  name: String
}

input UpdateCourseInput {
  name: String
  address: String
  phone: String
  website: String
  type: CourseType
  geolocation: GeolocationInput
  description: String
  paymentInformation: String
  access: CourseAccessType
  payToPlay: Boolean
  isPublished: Boolean
  publicStats: Boolean
  disableReviews: Boolean
  courseImageId: ID
}

input UpdateDivisionInput {
  taxRateId: ID
  maxSpots: Float
  reservedSpots: Float
  maxRegistrations: Float
  registrationFee: Float
  membershipRegistrationFee: Float
  tourPassFee: Float
  membershipTourPassFee: Float
  isAgeRestricted: Boolean
  isGenderLocked: Boolean
  refundPercentage: Float
}

input UpdateEventInput {
  name: String
  description: String
  maxSpots: Float
  maxRegistrations: Float
  isRegistrationOpen: Boolean
  maxWildcards: Float
  minGroupStartSize: Float
  registrationMethod: RegistrationMethod
  registrationOpenAt: DateTime
  registrationCloseAt: DateTime
  tournamentDirectorName: String
  assistantTournamentDirectorName: String
  assistantTournamentDirectorPhone: String
  assistantTournamentDirectorEmail: String
  phone: String
  email: String
  registrationFeesInfo: String
  paymentInfo: String
  location: String
  website: String
  isPublished: Boolean
  isVerifyMode: Boolean
  ratingEnabled: Boolean
  groupSize: Float
  isResultSigningEnabled: Boolean
  multipleScorecardModeEnabled: Boolean
  connectedAccountId: ID
  cityId: ID
  geolocation: GeolocationInput
  checkInStartsAt: DateTime
  checkInEndsAt: DateTime
  autoOpenRegistration: Boolean
  autoCloseInactivePools: Boolean
  autoConfirmRegistrations: Boolean
  pdgaEventId: String
  pdgaType: PdgaEventTypeEnum
  waitinglistType: WaitingListTypeEnum
  agreementName: String
  agreementUrl: String
  defaultToTeamName: Boolean
  teamSize: Float
  licenceRequiredFromAssociationId: String
  requireLicenceFromForeignPlayers: Boolean
  coverImageId: ID
  requireOfficialStatus: Boolean
  requireOrganizationMembership: Boolean
}

input UpdateGroupInput {
  startHoleId: ID
  startsAt: DateTime
  setAsDesignatedScorer: ID
  verifierDisabled: Boolean
}

input UpdateLayoutInput {
  name: String
  type: CourseType
  published: Boolean
  color: LayoutColorType
  description: String
  dogFriendly: Boolean
  wheelchairAccessible: Boolean
  strollerAccessible: Boolean
  cartAccessible: Boolean
  openForPlay: Boolean
  teepads: String
  baskets: String
  difficulty: LayoutDifficultyType
  upkeep: LayoutUpkeepType
  payToPlay: Boolean
}

input UpdateLayoutVersionInput {
  difficulty: DifficultyInput
  holes: [HoleInput]
}

input DifficultyInput {
  distance: Float!
  terrain: Float!
  precision: Float!
  obstacles: Float!
}

input UpdateMeUserInput {
  isPublicProfile: Boolean
  firstName: String
  lastName: String
  club: String
  instagram: String
  facebook: String
  twitter: String
  youtube: String
  tiktok: String
  sponsor: String
  biography: String
  pdgaNumber: Float
  pdgaEmail: String
  country: CountryCode
  phone: String
  pinCode: String
  birthDate: DateTime
  gender: GenderType
  socialSecurityId: String
  teeOffSongUrl: String
}

input UpdatePlayerInput {
  isWildcard: Boolean
  onSite: Boolean
  divisionId: ID
}

input UpdatePoolInput {
  name: String
  date: DateTime
  endDate: DateTime
  layoutVersionId: ID
  startMethod: PoolStartMethod
  playFormat: PoolPlayFormat
  areGroupsPublic: Boolean
}

input UpdateRegistrationInput {
  divisionId: ID
  groupId: ID
}

input UpdateTeamRegistrationInput {
  divisionId: ID
  groupId: ID
}

input UpdateResultInput {
  score: Float
  isCircleHit: Boolean
  isOutsidePutt: Boolean
  isInsidePutt: Boolean
  isOutOfBounds: Boolean
  penaltyStrokes: Float
}

type GroupScore {
  id: ID!
  score: Float!
  holeId: ID!
  userGroupId: ID
  teamGroupId: ID
  groupId: ID!
  scorerUserGroupId: ID
  scorerTeamGroupId: ID
}

input UpsertGroupScoreInput {
  score: Float!
}

type TeamGroupScore {
  id: ID!
  score: Float!
  holeId: ID!
  userGroupId: ID
  teamGroupId: ID
  groupId: ID!
  scorerUserGroupId: ID
  scorerTeamGroupId: ID
}

input UpsertTeamGroupScoreInput {
  score: Float!
}

input UpdateTeamResultInput {
  score: Float
  isCircleHit: Boolean
  isOutsidePutt: Boolean
  isInsidePutt: Boolean
  isOutOfBounds: Boolean
  penaltyStrokes: Float
}

input UpdateScorecardInput {
  date: DateTime
  layoutVersionId: ID
  startHoleId: ID
  status: ScorecardStatus
  playFormat: ScorecardPlayFormat
  name: String
}

input UpdateScorecardResultInput {
  score: Float
  isTapIn: Boolean
  isCircleHit: Boolean
  isOutsidePutt: Boolean
  isInsidePutt: Boolean
  isOutOfBounds: Boolean
  penaltyStrokes: Float
}

input UpdateTourInput {
  name: String
  description: String
  scoringType: ScoringType
  registrationMethod: RegistrationMethod
  scoreBasedOnNrOfEvents: Float
  sortLeaderboardByEventsPlayed: Boolean
  paymentType: TourPaymentType
  connectedAccountId: ID
  automaticRefunds: Boolean
  isArchived: Boolean
  type: String
  allowRegistrationMessage: Boolean
  feeIncluded: Boolean
  currency: String
  isPrivate: Boolean
  taxRateId: ID
  tourImageId: ID
  maxTourPassCount: Int
}

input UpdateUserInput {
  pdgaRating: Float
}

input UpdateTaxRateInput {
  name: String
  description: String
  active: Boolean
}

input UpdateShopItemInput {
  title: String
  description: String
  link: String
  amount: Int
  stock: Int
  eventShopImageId: ID
  taxRateId: ID
  isPublished: Boolean
  isAvailableAllEvents: Boolean
}

input UpdateOrderInput {
  comment: String
}

input UpdateLineItemInput {
  refundStatus: Boolean
  isDelivered: Boolean
}

"""Allows updating the display name of the document and toggle tour availability"""
input EventDocumentUpdateInput {
  displayName: String
  tourAvailable: Boolean
}

enum DevicePlatformType {
  IOS
  ANDROID
}

input CreateRegistrationStageInput {
  date: DateTime!
  active: Boolean!
  criterias: [CreateRegistrationCriteriaInput]
}

input CreateRegistrationCriteriaInput {
  type: RegistrationCriteriaType!
  value: String
}

input UpdateRegistrationStageInput {
  date: DateTime
  active: Boolean
}

input UpdateRegistrationCriteriaInput {
  type: RegistrationCriteriaType
  value: String
}

input CourseFacilityInput {
  name: String!
  type: CourseFacilityEnum!
  geolocation: GeolocationInput
}

input UpdateHoleInput {
  note: String
  name: String
}

input CreateEventMessageInput {
  subject: String!
  message: String!
  audience: EventMessageAudienceEnum!
  messageType: EventMessageTypeEnumType!
}

input UpdateEventMessageInput {
  subject: String
  message: String
  audience: EventMessageAudienceEnum
}

"""Users registered device, used primarily for receiving push notifications."""
type RegisteredDevice {
  id: ID!
  userId: ID!
  deviceToken: String!
  platform: String!
  deviceEndpoint: String!
  appVersion: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RegisteredDevicePlatform {
  """Device is added into the Android collection"""
  ANDROID
  """Device is added into the iOS collection"""
  IOS
}

input ShopItemInput {
  title: String!
  description: String
  link: String
  amount: Int!
  stock: Int = 0
  taxRateId: ID
  eventShopImageId: ID
  isPublished: Boolean = false
  isAvailableAllEvents: Boolean = false
}

"""Information about subscription"""
type Subscription {
  id: String!
  subscriptionId: String
  status: String!
  currentPeriodStart: Int
  currentPeriodEnd: Int
  startDate: Int
  endDate: Int
  cancelDate: Int
  sessionId: String
  expiresAt: Int
  url: String
}

enum RecurrenceEnum {
  MONTHLY
  ANNUALLY
}

enum TourPaymentVariant {
  SINGLES
  TEAMS
}

type ReindexElasticSearch {
  completed: Boolean
  indices: Int
}

input CreateCourseLayoutReviewInput {
  rating: Float!
  review: String!
  teepads: Float!
  baskets: Float!
  upkeep: Float!
  navigation: Float!
}

input UpdateCourseLayoutReviewInput {
  rating: Float
  review: String
  teepads: Float
  baskets: Float
  upkeep: Float
  navigation: Float
}

enum TourTransferStatus {
  ACCEPTED
  ACTIVE
  CANCELED
  REJECTED
}

"""Leaving a field emtpty will default to the division's value."""
input CreateEventDivisionOverrideInput {
  disabled: Boolean
  maxSpots: Float
  reservedSpots: Float
  maxRegistrations: Float
  registrationFee: Float
  refundPercentage: Float
}

"""Will update the override to matcht the new input, fields left out will be nulled."""
input UpdateEventDivisionOverrideInput {
  disabled: Boolean
  maxSpots: Float
  reservedSpots: Float
  maxRegistrations: Float
  registrationFee: Float
  refundPercentage: Float
}

input CreateFreeOrderInputType {
  shopItemId: ID!
  quantity: Int!
}

input OrganizationInput {
  type: OrganizationType!
  acceptMembers: AcceptMembers!
  publicMembersList: Boolean!
  name: String!
  contactName: String
  contactMail: String
  contactPhone: String
  contactWebsite: String
  connectedAccountId: String
  currency: String!
  cityId: String!
  geolocation: GeolocationInput
}

input UpdateOrganizationInput {
  fiscalYearStartMonth: Float
  acceptMembers: AcceptMembers
  publicMembersList: Boolean
  hidden: Boolean
  name: String
  contactName: String
  contactMail: String
  contactPhone: String
  contactWebsite: String
  connectedAccountId: String
  associationId: String
  currency: String
  cityId: String
  geolocation: GeolocationInput
}

input OrganizationMemberTypeInput {
  organizationId: ID!
  name: String!
  description: String
  fee: Float
  fullMember: Boolean
}

input UpdateOrganizationMemberTypeInput {
  membershipTypeId: ID!
  name: String
  description: String
  fee: Float
  archived: Boolean
  fullMember: Boolean
}

"""In what role the mutation should run as.
  If the role-check fails an NOT_AUTHORIZED error will be returned"""
enum UpdateOrganizationMemberRoleType {
  USER
  ORGANIZATION_ADMIN
  ORGANIZATION_OWNER
}

input UpdateOrganizationMemberInput {
  status: OrganizationMemberStatus
  usersMainClub: Boolean
  newMembershipTypeId: String
  extendMembership: Boolean
}

enum OrganizationMemberStatus {
  ACTIVE
  EXPIRED
  PENDING_REVIEW
  PENDING_PAYMENT
}

"""In what role the mutation should run as.
  If the role-check fails an NOT_AUTHORIZED error will be returned"""
enum DeleteOrganizationMemberRole {
  USER
  ORGANIZATION_ADMIN
  ORGANIZATION_OWNER
}

input OrganizationContentInput {
  title: String!
  body: String!
  type: OrganizationContentType!
  audience: OrganizationContentAudience!
  published: Boolean!
}

input UpdateOrganizationContentInput {
  title: String
  body: String
  audience: OrganizationContentAudience
  published: Boolean
}

input CreateMembershipInput {
  organizationMemberId: ID!
  organizationMemberTypeId: ID!
}

input RegistrationQuestionInputType {
  question: String!
  questionType: RegistrationQuestionVariant!
  mandatory: Boolean!
  options: [String]
  forDivisionsIds: [String]
}

input UpdateRegistrationQuestionInputType {
  question: String
  mandatory: Boolean
  options: [RegistrationQuestionOptionsInputType]
  forDivisionsIds: [String]
}

input RegistrationQuestionOptionsInputType {
  id: ID!
  value: String!
}

input CreateDiscInput {
  brand: String!
  mold: String!
  plastic: String!
  color: String!
  speed: Float!
  glide: Float!
  turn: Float!
  fade: Float!
  userEstimatedSpeed: Float
  userEstimatedGlide: Float
  userEstimatedTurn: Float
  userEstimatedFade: Float
  condition: Float
  description: String
}

input UpdateDiscInput {
  brand: String
  mold: String
  plastic: String
  color: String
  speed: Float
  glide: Float
  turn: Float
  fade: Float
  userEstimatedSpeed: Float
  userEstimatedGlide: Float
  userEstimatedTurn: Float
  userEstimatedFade: Float
  condition: Float
  description: String
}

input CreateThrowsInput {
  inTheBasket: Boolean!
  distanceToBasket: Float!
  lie: Lie!
  throwType: ThrowType
  lieGeolocation: GeolocationInput
  lieDifficulty: LieDifficulty
  restriction: ThrowRestriction
  shotShape: ShotShape
  nearMiss: NearMiss
  penalties: Float
  discId: ID
}

input UpdateThrowInput {
  inTheBasket: Boolean!
  distanceToBasket: Float!
  throwType: ThrowType
  lie: Lie!
  lieGeolocation: GeolocationInput
  lieDifficulty: LieDifficulty
  restriction: ThrowRestriction
  shotShape: ShotShape
  nearMiss: NearMiss
  penalties: Float
  discId: ID
}

input CreateOrganizationRoleInput {
  role: String!
  phone: String
  email: String
}

input UpdateOrganizationRoleInput {
  role: String!
  phone: String
  email: String
}

enum OrganizationConnectionStatusType {
  APPROVED
  CANCELLED
  REJECTED
}

input CreateEventPointsMapInput {
  eventId: ID
  positions: [EventCustomPointInput!]!
  tiePoint: TiePoint!
  defaultPoint: Int!
}

input EventCustomPointInput {
  position: Float!
  points: Float!
}

input UpdateEventPointsMapInput {
  positions: [UpdateEventCustomPointInput!]!
  tiePoint: TiePoint!
  defaultPoint: Int!
}

input UpdateEventCustomPointInput {
  position: Float!
  points: Float!
}

input OrganizationLeaderboardInput {
  organizationId: ID!
  title: String!
  description: String
  divisionTypes: [String!]
}

input OrganizationLeaderboardUpdateInput {
  title: String
  description: String
  divisionTypes: [String!]
}

input LeaderboardTourConfig {
  tourId: ID!
  scoreBasedOnNumberOfEvents: Float!
}

input UserSponsorInput {
  name: ID!
  sponsorUrl: String
}

input UpdateUserSponsorInput {
  name: String!
  sponsorUrl: String
}

"""Can specify eventTeamId or eventUserId but 
                not both or neither. Specify the pool if enalty is for a specific round / pool."""
input CreateEventPenaltyInput {
  penalty: Float!
  reason: String!
  poolId: ID
  eventUserId: ID
  eventTeamId: ID
}

"""Can only update the reason or the penalty amount."""
input UpdateEventPenaltyInput {
  penalty: Float!
  reason: String!
}

input CreateEventBoonInput {
  par: Float
  score: Float
  points: Float
  onlyApplicableForTour: Boolean
  reason: String!
  icon: BoonIcon
  eventUserId: ID
  eventTeamId: ID
}

input TeamConfigurationInput {
  divisionId: ID!
  teamSize: Float!
  numberOfTeams: Float!
}

input CreateEventGameInput {
  name: String!
  type: EventGameCategory!
  description: String
  automaticallyAddPlayers: Boolean!
}

input UpdateEventGameInput {
  name: String
  description: String
  automaticallyAddPlayers: Boolean
}

input CreateEventGameRoundInput {
  date: DateTime!
  stationLayoutId: ID
  automaticallyAssignPlayers: Boolean
}

input UpdateEventGameRoundInput {
  date: DateTime
  stationLayoutId: ID
  status: EventGameRoundStatus
  automaticallyAssignPlayers: Boolean
}

input CreateEventGameStationInput {
  name: String!
  attempts: Float!
  attemptsCounted: Float
  pointsAwardedPerAttempt: Float
}

input CreateTourPassInput {
  divisionId: ID!
  uses: Int
  stock: Int = null
  fee: Int
  membershipFee: Int
  active: Boolean = true
  alwaysAvailable: Boolean = false
}

input UpdateTourPassInput {
  name: String
  uses: Int
  stock: Int
  fee: Int
  membershipFee: Int
  active: Boolean
  alwaysAvailable: Boolean
}

input PurchaseTourPassInput {
  tourPassId: ID!
  teamId: ID
}

input UpdateFriendshipInput {
  isBlocked: Boolean
  note: String
  pushNotificationsEnabled: Boolean
}

type SignedUploadParams {
  uploadUrl: String!
  uploadToken: String!
  signature: String
  timestamp: Int
  cloudName: String
  apiKey: String
  folder: String
  allowedFormats: [String]
}

type RefreshPdgaDataResponse {
  success: Boolean!
  message: String
}